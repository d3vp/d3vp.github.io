{"pageProps":{"allSlugs":[["Lecture-1",[{"title":"1 — Programming Basics","slug":"Lecture-1"}]],["Lecture-2.1",[{"title":"2.1 — Variables, Arithmetic & String operations","slug":"Lecture-2.1"}]],["Lecture-2.2",[{"title":"2.2 — Function calls, Defining functions, Types of Errors","slug":"Lecture-2.2"}]],["Lecture-3.1",[{"title":"3.1 — Order of Expression Evaluation, Comparing Values, Conditional Execution","slug":"Lecture-3.1"}]],["Lecture-3.2",[{"title":"3.2 — if statement, for loop, Indexing & Slicing Strings","slug":"Lecture-3.2"}]],["Lecture-4.1",[{"title":"4.1 — return vs. print, while statement, Modules","slug":"Lecture-4.1"}]],["Lecture-4.2",[{"title":"4.2 — String methods, break & continue statements","slug":"Lecture-4.2"}]],["Lecture-5.1",[{"title":"5.1 — Controlling print(), Nested Loops, Lists","slug":"Lecture-5.1"}]],["Lecture-5.2",[{"title":"5.2 — Scope of variables, List operations","slug":"Lecture-5.2"}]],["Lecture-6.1",[{"title":"6.1 — Tuples, Immutable objects, Sets","slug":"Lecture-6.1"}]],["Lecture-6.2",[{"title":"6.2 — More list & set operations, Dictionaries","slug":"Lecture-6.2"}]],["Lecture-7.1",[{"title":"7.1 — Iterables, Unpacking, Nested Lists","slug":"Lecture-7.1"}]],["Lecture-7.2",[{"title":"7.2 — Nested data structures, Comprehensions, Modules","slug":"Lecture-7.2"}]],["Lecture-8.1",[{"title":"8.1 — Nested list comprehensions, Reading & Writing Files","slug":"Lecture-8.1"}]],["Lecture-8.2",[{"title":"8.2 — Shallow vs. deep copy, Handling exceptions","slug":"Lecture-8.2"}]],["Lecture-9.1",[{"title":"9.1 — Object Oriented Programming (OOP)","slug":"Lecture-9.1"}]],["Lecture-9.2",[{"title":"9.2 — Keyword arguments, More on OOP","slug":"Lecture-9.2"}]],["Lecture-10.1",[{"title":"10.1 — NumPy","slug":"Lecture-10.1"}]],["Lecture-10.2",[{"title":"10.2 — More Numpy, Plotting using Matplotlib","slug":"Lecture-10.2"}]],["Lecture-11.1",[{"title":"11.1 — More Numpy, Linear algebra, Random numbers","slug":"Lecture-11.1"}]],["Lecture-11.2",[{"title":"11.2 — Interpolation, Curve fitting, Numerical Integration","slug":"Lecture-11.2"}]],["Lecture-12.1",[{"title":"12.1 — Using SciPy, System of Linear Equations","slug":"Lecture-12.1"}]],["Lecture-12.2",[{"title":"12.2 — Root Finding, Sorting algorithms","slug":"Lecture-12.2"}]],["Lecture-13.1",[{"title":"13.1 — Sorting & Misc. topics","slug":"Lecture-13.1"}]]],"post":{"slug":"Lecture-13.1","content":"<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"binary-search-algorithm\">Binary search algorithm</h2><p>We have seen examples which perform linear search using a loop:</p><python>def linear_search(sequence, target):\n    for index in range(len(sequence)):\n        if sequence[index] == target:\n            return index\n\n    return -1  # Not found\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"\"></h2><ul>\n<li>Binary search is a faster algorithm to search an item in a sequence, provided the sequence is <i>sorted</i>.</li>\n<li>Binary search is similar to looking up a word in an English dictionary. Suppose we are looking for the word “doctor”\n<ul>\n<li>We flip pages in the dictionary to find the “d” section but we may end up a little further to the right, say at “f” section.</li>\n<li>Then we flip pages to the left and may end up at “da” section.</li>\n<li>Then we flip pages to the right towards “do” and so on…</li>\n<li>At each step, we decrease the number of pages to search.</li>\n<li>The process works because the dictionary is sorted in alphabetical order.</li>\n</ul>\n</li>\n</ul></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-1\"></h2><p><b class=\"sans\">Visualize the binary search algorithm</b></p><iframe width=\"900\" height=\"600\" frameborder=\"0\" style=\"background-color: white;\" src=\"https://observablehq.com/embed/@d3vp/binary-search-algorithm?cells=view%2Cviewof+sequence%2Cviewof+item_to_search%2Cbuttons\"></iframe></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-2\"></h2><p><b class=\"sans\">Implementation</b></p><python>def binary_search(sequence, target):\n    low = 0\n    high = len(sequence) - 1\n\n    while low &#x3C;= high:\n        middle = (low + high) // 2  # floor division\n\n        if sequence[middle] &#x3C; target:\n            low = middle + 1\n        elif sequence[middle] > target:\n            high = middle -1\n        else:\n            return middle\n\n    return -1  # Not found\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-3\"></h2><ul>\n<li>In general, if the length of sequence is <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>\n<ul>\n<li>Linear search takes time proportional to <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span></li>\n<li>Binary search takes time proportional to <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">log(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span></li>\n</ul>\n</li>\n</ul></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"sorting-algorithms\">Sorting algorithms</h2><ul>\n<li>\n<p>Sorting algorithms sort a sequence into ascending or descending order.</p>\n<pre class=\"code\"><p>[1, 3, 2, 0] → [0, 1, 2, 3]\n[‘a’, ‘c’, ‘b’, ‘d’] →  [‘a’, ‘b’, ‘c’, ‘d’]</p></pre>\n</li>\n<li>\n<p>There are many sorting algorithms which have different speed and computer memory requirements.</p>\n</li>\n<li>\n<p>We will only cover two — Selection sort and Insertion sort</p>\n</li>\n</ul></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"selection-sort-algorithm-and-implementation\">Selection sort algorithm and implementation</h2><p>Visualize algorithm: <a href=\"https://visualgo.net/en/sorting\">https://visualgo.net/en/sorting</a></p></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-4\"></h2><python>def selection_sort(seq):\n    N = len(seq)\n    \n    for i in range(N):\n        # Assume that element at index i is minimum\n        min_index = i\n        \n        # Find minimum of unsorted elements on right of i\n        for k in range(i+1, N):\n            if seq[k] &#x3C;= seq[min_index]:\n                min_index = k\n\n        # Swap elements at i and min_index\n        temp = seq[i]\n        seq[i] = seq[min_index]\n        seq[min_index] = temp\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-5\"></h2><p>Run <inline-code>selectionsort.py</inline-code> to see the sequence after each iteration.</p></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"insertion-sort-algorithm-and-implementation\">Insertion sort algorithm and implementation</h2><p>Visualize algorithm: <a href=\"https://visualgo.net/en/sorting\">https://visualgo.net/en/sorting</a></p></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-6\"></h2><p>First let’s look at a single step when we have a partially sorted list of size <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span> and want to move an element to have a bigger partially sorted list of size <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>.</p></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-7\"></h2><python>sequence = [9, 22, 51, 63, 10, 79, 60, 75]  # partially sorted list\n\ni = 4\nkey = sequence[i]  # 10\n\n# Elements on the left of key are sorted.\n# We want to insert key on the left to keep the partial list sorted.\n# Shift elements one place to the right if they are greater than key. \nj = i - 1\nwhile(j >= 0 and sequence[j] > key):\n    sequence[j+1] = sequence[j]\n    j = j - 1\n\n# Moving key to index j+1\nsequence[j+1] = key\nprint(sequence)  # [9, 10, 22, 51, 63, 79, 60, 75]\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-8\"></h2><p>Now, we can look at the final insertion sort implementation:</p><python>def insertion_sort(seq):\n    N = len(seq)\n        \n    for i in range(1, N):\n        key = seq[i]\n        \n        # Elements on the left of key are already sorted.\n        # Shift them one place to the right if they are greater than key.\n        j = i - 1\n        while(j >= 0 and seq[j] > key):\n            seq[j+1] = seq[j]\n            j = j - 1\n        \n        # After shifting right, index j+1 is now available for key\n        seq[j+1] = key\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-9\"></h2><p>Run <inline-code>insertionsort.py</inline-code> to see the sequence after each iteration.</p></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"iterables\">Iterables</h2><p><a href=\"https://docs.python.org/3/glossary.html#term-iterable\">https://docs.python.org/3/glossary.html#term-iterable</a></p><p>An object capable of returning its members one at a time.</p><ul>\n<li>all sequence types (such as list, str, and tuple)</li>\n<li>some non-sequence types like dict, file objects</li>\n<li>objects of any class that implements <inline-code>__iter__()</inline-code> or <inline-code>__getitem__()</inline-code> method.</li>\n</ul><p>Iterables can be used in a for loop and in many other places where a sequence is needed (<inline-code>zip()</inline-code>, <inline-code>map()</inline-code>, etc.).</p></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-10\"></h2><ul>\n<li>When an iterable object is passed as an argument to the built-in function <inline-code>iter()</inline-code>, it returns an <sc>iterator</sc> for the object.</li>\n<li>This iterator is good for one pass over the set of values.</li>\n<li>Repeated calls to the iterator’s <inline-code>__next__()</inline-code> method (or passing it to the built-in function next()) return successive items in the stream.</li>\n<li>When no more data are available a <inline-code>StopIteration</inline-code> exception is raised instead by <inline-code>__next__()</inline-code> method.</li>\n</ul></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-11\"></h2><python>>>> rng = range(1, 6, 2)\n>>> it = iter(rng)  # create iterator\n>>> next(it)\n1\n>>> next(it)\n3\n>>> next(it)\n5\n>>> next(it)\nTraceback (most recent call last):\n  File \"&#x3C;stdin>\", line 1, in &#x3C;module>\nStopIteration\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-12\"></h2><ul>\n<li>When using iterables, it is usually not necessary to call <inline-code>iter()</inline-code> or deal with iterator objects ourselves.</li>\n<li>The <inline-code>for</inline-code> statement does that automatically for us, creating a temporary variable to hold the iterator for the duration of the loop.</li>\n</ul><hgrid><python>for x in some_iterable:\n    do_something(x)\n</python><python>it = iter(some_iterable)\nwhile True:\n    try:\n        x = next(it)\n        do_something(x)\n    except StopIteration:\n        break\n</python></hgrid></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"our-simple-range-implementation\">Our simple <inline-code>range</inline-code> implementation</h2><hgrid><python>class MyRange:  \n    # assume step will be positive\n    def __init__(self, start, stop, step):\n        self.start = start\n        self.stop = stop\n        self.step = step\n        self.value = start\n        \n    def nextValue(self):\n        value = self.value\n        if value &#x3C; self.stop:\n            self.value += self.step\n            return value\n</python><python>rng = MyRange(1, 8, 2)\nwhile True:\n    val = rng.nextValue()\n    if not val:\n        break\n    \n    print(val)\n</python></hgrid></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-13\"></h2><hgrid><python>class MyRange:  \n    # assume step will be positive\n    def __init__(self, start, stop, step):\n        self.start = start\n        self.stop = stop\n        self.step = step\n        self.value = start\n        \n    def nextValue(self):\n        value = self.value\n        if value &#x3C; self.stop:\n            self.value += self.step\n            return value\n        raise StopIteration()\n</python><python>rng = MyRange(1, 8, 2)\nwhile True:\n    try:\n        val = rng.nextValue()\n        print(val)\n    except StopIteration:\n        break\n</python></hgrid></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-14\"></h2><hgrid><python>class MyRange:  \n    # assume step will be positive\n    def __init__(self, start, stop, step):\n        self.start = start\n        self.stop = stop\n        self.step = step\n        self.value = start\n        \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        value = self.value\n        if value &#x3C; self.stop:\n            self.value += self.step\n            return value\n        raise StopIteration()\n</python><python>rng = MyRange(1, 8, 2)\nfor val in rng:\n    print(val)\n</python></hgrid></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-15\"></h2><python>import random\n\nclass RandomIter:\n    def __init__(self, num):\n        self.num = num\n        self.index = 0\n        \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.index &#x3C; self.num:\n            self.index += 1\n            return random.random()\n        raise StopIteration()\n        \n        \nfor val in RandomIter(4):\n    print(val)\n\n</python></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"generators-using-yield-statement\">Generators using <inline-code>yield</inline-code> statement</h2><python>def myrange(start, stop, step):\n    value = start\n    \n    while True:\n        if value >= stop:\n            break\n        \n        yield value\n        value += step\n\n\nfor x in myrange(1, 8, 2):\n    print(x)\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-16\"></h2><python>import random\n\n\ndef random_iter(num):\n    for i in range(num):\n        yield random.random()\n\n\nfor x in random_iter(5):\n    print(x)\n    \n\nprint(list(random_iter(4)))\n</python></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"functions-are-first-class-citizens\">Functions are first-class citizens</h2><p>Functions can be used in same way as any other Python objects:</p><ul>\n<li>Functions can be passed function as arguments</li>\n<li>Functions can be created inside other functions</li>\n<li>A function can be returned from other function.</li>\n</ul></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"useful-examples-of-passing-functions-as-arguments\">Useful examples of passing functions as arguments</h2><python>points = [(1, 1, 3), (4, 10, 9), (7, 4, 11)]\n\n\ndef key_func(p):\n    return p[1], p[0], p[2]\n\n\nprint(max(points, key=key_func))\n\nprint(sorted(points, key=key_func))\n</python></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"lambda\">lambda</h2><p>An anonymous inline function consisting of a single expression which is evaluated when the function is called.</p><p>The syntax to create a lambda function is</p><python>f = lambda param1, param2, ...: some_expression\n</python><p>Equivalent to</p><python>def f(param1, param2, ...):\n    return some_expression\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-17\"></h2><python>diagnostic_frequencies = {'pharyngitis': 1,\n                          'meningitis': 1,\n                          'food_poisoning': 2}\n\nmaxKey = max(diagnostic_frequencies,\n             key=lambda k: diagnostic_frequencies[k])\nprint(maxKey)\n\nmaxKey = max(diagnostic_frequencies,\n             key=diagnostic_frequencies.get)\nprint(maxKey)\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-18\"></h2><python>words = [(\"happy\", 0.7), (\"sad\", -0.9),\n         (\"fun\", 0.58), (\"enemy\", -0.4)]\n\nwords_sorted = sorted(words, key=lambda tup: tup[1])\nprint(words_sorted)\n</python></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"built-in-map-function\">Built-in <inline-code>map</inline-code> function</h2><p><inline-code>map(func, iterable)</inline-code> applies a function <inline-code>func</inline-code> to every item of an iterable, yielding the results.</p><p>In very simplified terms, <inline-code>map()</inline-code> does something like:</p><python>def map(func, iterable):\n    for item in iterable:\n        yield func(item)\n</python><p>Examples:</p><python>x = [\"23\", \"3.14\", \"1.61\"]\ny = list(map(float, x))\nprint(y)\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-19\"></h2><python>inventory = {\"sofa\": 10, \"chair\": 5, \"lamp\": 3}\nnew_inventory = dict(map(lambda item: (item[0].upper(), item[1]+10),\n                         inventory.items()))\nprint(new_inventory)\n</python><python>persons = [['music', 'running', 'reading'],\n           ['movies', 'boardgames'],\n           ['boardgames', 'running', 'hiking']]\n\nnewlist = list(map(set, persons))\nprint(newlist)\n</python></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"other-built-in-functions-that-work-with-iterables\">Other built-in functions that work with iterables</h2><p><inline-code>filter(func, iterable)</inline-code>: yields items from <inline-code>iterable</inline-code> for which <inline-code>func(item)</inline-code> is <inline-code>True</inline-code>. Equivalent to:</p><python>def filter(func, iterable):\n    for item in iterable:\n        if func(item):\n            yield item\n</python><python>nums = [-2, 10, -5, 7]\npositive = list(filter(lambda x: x > 0, nums))\nprint(positive)  # [10, 7]\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-20\"></h2><p><inline-code>all(iterable)</inline-code>: Return <inline-code>True</inline-code> if all items of the <inline-code>iterable</inline-code> are true (or if the iterable is empty). Equivalent to:</p><python>def all(iterable):\n    for item in iterable:\n        if not item:\n            return False\n    return True\n</python><python>nums = [2, 4, 6, 8]\nprint(all([x % 2 == 0 for x in nums]))  # True\n\nnums = [1, 4, 6, 8]\nprint(all([x % 2 == 0 for x in nums]))  # False\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-21\"></h2><p><inline-code>any(iterable)</inline-code>: Return <inline-code>True</inline-code> if any item of the iterable is true. If the iterable is empty, return <inline-code>False</inline-code>. Equivalent to:</p><python>def any(iterable):\n    for item in iterable:\n        if item:\n            return True\n    return False\n</python><python>nums = [2, 3, 5, 7]\nprint(any([x % 2 == 0 for x in nums]))  # True\n\nnums = [1, 3, 5, 7]\nprint(any([x % 2 == 0 for x in nums]))  # False\n</python></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"innernested-functions\">Inner/Nested functions</h2><ul>\n<li>Functions can be defined inside other functions.</li>\n<li>This is useful to create helper functions that are not used outside of a function — Encapsulates (hides) inner functions.</li>\n</ul><python>def main_function():\n    def helper(params):\n        print(\"do something\", params)\n\n    helper(\"hello\")\n    helper(123)\n\n\nmain_function()\nhelper()\n</python></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"closure\">Closure</h2><p>An enclosed (i.e. inner/nested) function has access to local variables and parameters of outer (enclosing) function.</p><hgrid><python>def create_quadratic(a, b, c):\n    def quadratic(x):\n        return a * x ** 2 + b * x + c\n\n    return quadratic\n\n# q1 and q2 are functions:\nq1 = create_quadratic(1, 3, 10)\nq2 = create_quadratic(-5, -1, 0)\n</python><python>import numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(-20, 20, 1000)\nplt.plot(x, q1(x), \"r\")\nplt.plot(x, q2(x), \"b\")\nplt.show()\n</python></hgrid></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"last-lecture-next-week\">Last lecture next week</h2><ul>\n<li>Examples using SciPy</li>\n<li>Final exam overview</li>\n<li>Practice problems from past exams</li>\n</ul><divider></divider></slide>","title":"13.1 — Sorting & Misc. topics","date":"2024-04-02","published":true,"section":"Lecture-13.1"}},"__N_SSG":true}