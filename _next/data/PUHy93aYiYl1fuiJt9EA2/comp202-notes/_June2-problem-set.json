{"pageProps":{"titles":["L1.1 — Computer and Programming Basics","L1.2 — Variables & Expressions","L2.1 — Control Flow Statements","Python Style Guide","May 14 — Problem Set","L2.2 — print(), String methods & while loop","May 17 — Problem Set","L3.1 — More loops & Defining functions","May 19 — Problem Set","L3.2 — Lists","May 21 — Problem Set","L4.1 — Tuples, Dictionaries, Sets","May 26 — Problem Set","May 28 — Problem Set","L4.2 — Nested data structures","June 2 — Problem Set","June 4 — Problem Set","L5.1 — Handling Exceptions, File IO","L5.2 — Comparing data structures, Writing modules, Matplotlib","June 9 — Problem Set","L6.1 — Object oriented programming"],"slugs":["Lecture-1.1","Lecture-1.2","Lecture-2.1","style-guide","_May14-problem-set","Lecture-2.2","_May17-problem-set","Lecture-3.1","_May19-problem-set","Lecture-3.2","_May21-problem-set","Lecture-4.1","_May26-problem-set","_May28-problem-set","Lecture-4.2","_June2-problem-set","_June4-problem-set","Lecture-5.1","Lecture-5.2","_June9-problem-set","Lecture-6.1"],"post":{"title":"June 2 — Problem Set","slug":"_June2-problem-set","content":"<h1>Problems</h1>\n<ol>\n<li>\n<p>Consider the following commonly used pattern of counting things:</p>\n<python>mylist = [\"A\", 1, \"A\", 1, 10, 1]\n\ncounter = {}\nfor x in mylist:\n    if x not in counter:\n        counter[x] = 1\n    else:\n        counter[x] += 1\n        \nprint(counter)\n</python>\n<p>Now, we look at a method <inline-code>get</inline-code> available on a dictionary object.<br>\n<inline-code>dict.get(key, default_value)</inline-code> returns the value in dictionary associated with the given <inline-code>key</inline-code> if <inline-code>key</inline-code> is present in the dictionary, otherwise returns the <inline-code>default_value</inline-code>.</p>\n<python>d = {\"A\": 2}\n\n# Key \"A\" exists in d so its associated value in d is returned\nprint(d.get(\"A\", 0))  \n# 2\n\n# Key 123 does not exist in d, so default value 0 is returned\nprint(d.get(123, 0)) \n# 0\n</python>\n<p>Use the <inline-code>get</inline-code> method to simplify the counter example above, so that you don’t need an <inline-code>if-else</inline-code> in the <inline-code>for</inline-code> loop.</p>\n<solution><python>mylist = [\"A\", 1, \"A\", 1, 10, 1]\n\ncounter = {}\nfor x in mylist:\n    counter[x] = counter.get(x, 0) + 1\n\nprint(counter)\n</python></solution>\n</li>\n<li>\n<p>Write a function <inline-code>invert</inline-code> that takes a dictionary <inline-code>dct</inline-code> as argument and returns an inverted dictionary <inline-code>inv</inline-code>, where keys in <inline-code>dct</inline-code> become values in <inline-code>inv</inline-code> and values in <inline-code>dct</inline-code> become keys in <inline-code>inv</inline-code>. Since keys are unique in any dictionary but values need not be unique, the inverted dictionary will need to use a list for values. For example,</p>\n<python>letter_counts = {\"a\": 1, \"b\": 1, \"apple\": 5, \"bus\": 3, \"cat\": 3, \"dog\": 3}\nprint(invert(letter_counts))\n</python>\n<output>{1: ['a', 'b'], 5: ['apple'], 3: ['bus', 'cat', 'dog']}\n</output>\n<p>In the above example, since <inline-code>letter_counts</inline-code> contains duplicate values such as <inline-code>1</inline-code>, when those values become keys in the inverted dictionary, we will need a list, e.g. <inline-code>1: ['a', 'b']</inline-code></p>\n<solution><python>def invert(dct):\n    result = {}\n    \n    for key in dct:\n        val = dct[key]\n        if val not in result:\n            result[val] = [key]\n        else:\n            result[val].append(key)\n        \n    return result\n\n\nletter_counts = {\"a\": 1, \"b\": 1, \"apple\": 5, \"bus\": 3, \"cat\": 3, \"dog\": 3}\n\nprint(invert(letter_counts))\n# {1: ['a', 'b'], 5: ['apple'], 3: ['bus', 'cat', 'dog']}\n</python></solution>\n</li>\n<li>\n<p>Write a function <inline-code>flatten</inline-code> that takes a 2D list (a list of lists) <inline-code>lst</inline-code> as an argument and returns a flattened (non-nested) list which contains all elements from <inline-code>lst</inline-code></p>\n<python>nested_list = [[1, 2, 3], [100, 245, 300]]\nflat_list = flatten(nested_list)\nprint(flat_list)\n</python>\n<output>[1, 2, 3, 100, 245, 300]\n</output>\n<solution><python>def flatten(lst):\n    result = []\n    for inner_list in lst:\n        for x in inner_list:\n            result.append(x)\n            \n    return result\n\n\nnested_list = [[1, 2, 3], [100, 245, 300]]\nflat_list = flatten(nested_list)\nprint(flat_list)\n# prints:\n# [1, 2, 3, 100, 245, 300]\n</python></solution>\n</li>\n<li>\n<p>Write a function <inline-code>matrix_sum</inline-code> that takes two matrices (list of lists) as arguments, call them A and B, and returns a matrix C (list of lists), such that C is the element-wise sum of A and B i.e. <inline-code>C[i][j] = A[i][j] + B[i][j]</inline-code> for all <inline-code>i, j</inline-code>. You can assume that A and B will be of same size (no. of rows and columns will be same.)</p>\n<ul>\n<li>You will need to first create a matrix C (list of lists) such that it contains all zeros.\n<ul>\n<li>To do so, suppose <inline-code>nrows</inline-code> in no. of rows and <inline-code>ncols</inline-code> is no of columns in A (or B, they are same size).</li>\n<li>Then to create a matrix C with zeros, you first create and empty list and then append to it <inline-code>nrows</inline-code> number of lists, each of which contain <inline-code>ncols</inline-code> number of zeros.</li>\n</ul>\n</li>\n<li>Then using nested loops you perform the operation <inline-code>C[i][j] = A[i][j] + B[i][j]</inline-code> for all <inline-code>i, j</inline-code></li>\n</ul>\n<python>matrix1 = [[1, 2, 3],\n        [4, 5, 6]]\nmatrix2 = [[1, 2, 3],\n        [1, 1, 1]]\nresult = matrix_sum(matrix1, matrix2)\nprint(result)\n</python>\n<output>[[2, 4, 6], [5, 6, 7]]\n</output>\n<solution><python>def matrix_sum(A, B):\n    nrows = len(A)\n    ncols = len(A[0])\n    C = []\n    \n    for i in range(nrows):\n        C.append([0] * ncols)\n    \n    for i in range(nrows):\n        for j in range(ncols):\n            C[i][j] = A[i][j] + B[i][j]\n    \n    return C\n\n\nmatrix1 = [[1, 2, 3],\n        [4, 5, 6]]\nmatrix2 = [[1, 2, 3],\n        [1, 1, 1]]\nresult = matrix_sum(matrix1, matrix2)\nprint(result)\n# prints:\n# [[2, 4, 6], [5, 6, 7]]\n</python></solution>\n</li>\n<li>\n<p>Recall how we can iterate over a matrix in the row-first order:</p>\n<div class=\"flex\"><python>matrix = [[81, 75, 90, 60], \n        [80, 70, 85, 55],\n        [40, 50, 45, 85]]\n\nnum_rows = len(matrix)  # no. of inner lists\nnum_cols = len(matrix[0])  # length of an inner list\n\nfor r in range(num_rows):\n    print(\"Row\", r, \":\")\n    for c in range(num_cols):\n        print(matrix[r][c])\n</python><output>Row 0 :\n81\n75\n90\n60\nRow 1 :\n80\n70\n85\n55\nRow 2 :\n40\n50\n45\n85\n</output></div>\n<p>Modify the code above to product the following output. Here we want to iterate over a matrix in column-first order.</p>\n<output>Column 0 :\n81\n80\n40\nColumn 1 :\n75\n70\n50\nColumn 2 :\n90\n85\n45\nColumn 3 :\n60\n55\n85\n</output>\n<solution><python>matrix = [[81, 75, 90, 60], \n          [80, 70, 85, 55],\n          [40, 50, 45, 85]]\n\nnum_rows = len(matrix)  # no. of inner lists\nnum_cols = len(matrix[0])  # length of an inner list\n\nfor c in range(num_cols):  # Outer loop for column index\n    print(\"Column\", c, \":\")\n    for r in range(num_rows):  # Inner loop for row index\n        print(matrix[r][c])\n</python></solution>\n</li>\n<li>\n<p>Write a function <inline-code>max_in_columns</inline-code> that takes a <inline-code>matrix</inline-code> (list of lists) and computes max value of each column. The function should return a list which contains a maximum value for each column in <inline-code>matrix</inline-code>.</p>\n<python>matrix = [[81, 75, 90, 60], \n          [80, 70, 85, 55],\n          [40, 50, 45, 85]]\n\nprint(max_in_columns(matrix))\n</python>\n<output>[81, 75, 90, 85]\n</output>\n<solution><python>def max_in_columns(matrix):\n    result = []\n    num_rows = len(matrix) \n    num_cols = len(matrix[0])\n\n    for c in range(num_cols):\n        current_col = []\n        for r in range(num_rows):\n            current_col.append(matrix[r][c])\n        result.append(max(current_col))\n    \n    return result\n\nmatrix = [[81, 75, 90, 60], \n          [80, 70, 85, 55],\n          [40, 50, 45, 85]]\n\nprint(max_in_columns(matrix))\n# [81, 75, 90, 85]\n</python></solution>\n</li>\n</ol>\n<p><img style=\"display: block; margin: 3em auto; width: 15%;\" src=\"../assets/divider.svg\"></p>"}},"__N_SSG":true}