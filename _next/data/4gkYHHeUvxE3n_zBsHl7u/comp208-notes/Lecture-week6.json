{"pageProps":{"titles":["Week 1 — Computer and Programming Basics","Week 2 — Types, Variables, Expressions, Functions","Sep 9-10 Problem Set 2","Week 3 —  Conditionals & Iteration","Sep 16-17 Problem Set","Week 4 —  print(), String methods, while loop","Python Style Guide","Sep 23-24 Problem Set","Week 5 —  Scope of variables, Lists & Tuples","Sep 30-Oct 1 Problem Set","Week 6 —  Immutability, Dictionary & Set","Oct 7-8 Problem Set","Week 7 —  Nested data structures, iterables, comprehensions","Week 8 —  Exceptions & File IO","Oct 21-22 Problem Set","Week 9 — Object oriented programming","Oct 28-29 — Problem Set","Week 10 — NumPy & Matplotlib","Nov 4-5 More on NumPy & Problems","Week 11 — Roots, Interpolation, Curve fitting","Week 12 — System of linear equations, Numerical Integration","Nov 18-19 — NumPy & Problem Set","Week 13 — Binary search, Sorting, Random numbers"],"slugs":["Lecture-1.2","Lecture-week2","_Sep09-problem-set","Lecture-week3","_Sep16-17-problem-set","Lecture-week4","style-guide","_Sep23-24-problem-set","Lecture-week5","_Sep30-Oct1-problem-set","Lecture-week6","_Oct7-8-problem-set","Lecture-week7","Lecture-week8","_Oct21-22_problem-set","Lecture-week9","_Oct28-29_problem-set","Lecture-week10","_Nov4-5_problem-set","Lecture-week11","Lecture-week12","_Nov18-19_problem-set","Lecture-week13"],"post":{"title":"Week 6 —  Immutability, Dictionary & Set","slug":"Lecture-week6","content":"<h1>Object Identity</h1>\n<ul>\n<li>Each object is assigned an <sc>ID</sc> at its creation (think of a memory address).</li>\n<li>This ID is unique and constant for this object as long as the object exists.</li>\n<li>The built-in function <inline-code>id()</inline-code> can be used to retrieve the ID of an object.</li>\n</ul>\n<python>x = 1234\ny = x\n\n# x and y both point to the same object, \n# therefore the IDs are the same.\nprint(id(x) == id(y))  # True\n\n# x and y point to two different objects, \n# therefore we expect x and y to have different IDs.\nx = 1234\ny = 5678\nprint(id(x) == id(y))  # False\n\n# x and y point to two different objects (with the same value),\n# therefore we expect x and y to have different IDs.\nx = int(\"1234\")  # integer 1234\ny = int(\"12\" + \"34\")  # integer 1234\n\nprint(id(x) == id(y))  # False\n</python>\n<h2>Identity operators</h2>\n<ul>\n<li><inline-code>is</inline-code> and <inline-code>is not</inline-code> are comparison operators used to determine if the two operands have the same identity (i.e refer to the same object)</li>\n<li>Note that this is NOT the same thing as checking for equality using <inline-code>==</inline-code> operator!\n<ul>\n<li>Using <inline-code>is</inline-code> operator means: are two variables referring to one and the same object?</li>\n<li>Using <inline-code>==</inline-code> operator means: are two variables referring to objects that contain same data?</li>\n</ul>\n</li>\n</ul>\n<div class=\"flex\" style=\"width: 120%; margin-left: -3em;\"><python>x = int(\"1234\")  # 1234\ny = int(\"12\" + \"34\")  # 1234\nz = x \nprint(x == y)  # True\nprint(x == z)  # True\n</python><python>x = int(\"1234\")  # 1234\ny = int(\"12\" + \"34\")  # 1234\nz = x \nprint(x is y)  # False\nprint(x is z)  # True\n</python><python>x = 1234 \ny = 5678\nprint(x is y)  # False\nprint(x == y)  # False\nprint(x is not y)  # True\n</python></div>\n<h1>Mutable vs Immutable objects</h1>\n<p><sc>Immutable</sc>: the content of the object cannot be changed after the object has been created.</p>\n<ul>\n<li>e.g. <inline-code>str</inline-code>, <inline-code>int</inline-code>, <inline-code>float</inline-code>, <inline-code>tuple</inline-code></li>\n</ul>\n<p><sc>Mutable</sc>: the content of the object can be changed after its creation without changing its identity.</p>\n<ul>\n<li>e.g. <inline-code>list</inline-code>, <inline-code>dict</inline-code>, <inline-code>set</inline-code></li>\n</ul>\n<h2>Strings are immutable</h2>\n<p>Unlike lists, we cannot use the square brackets to modify a character in the string.<br>\nFor example:</p>\n<python>s = \"cats\"\ns[0] = \"r\"  # TypeError: 'str' object does not support item assignment\n</python>\n<p>All strings operations that seem to change a string actually <i>create</i> a new string.</p>\n<python>s = \"cat\"\nt = s\nprint(\"Before:\", s is t)\ns = s.replace('c','r')\nprint(\"After:\", s is t)\nprint(\"s:\", s)\nprint(\"t:\", t)\n</python>\n<output>Before: True\nAfter: False\ns: rat\nt: cat\n</output>\n<h2>Lists are mutable</h2>\n<p>The following code does not create a copy of the list <inline-code>x</inline-code>.<br>\nIt simply create a new variable name for the same list.</p>\n<python>x = [1, 2, 3]\ny = x  # new name y for same list\n\nprint(x is y)  # True\n</python>\n<p>Let us see some implications of this.</p>\n<p>In the following illustrations, think about what is modified.</p>\n<ul>\n<li>Whether a variable changes its value i.e. the variable refers to a different value</li>\n<li>Whether a list object is modified i.e. some element of the list is changed.</li>\n</ul>\n<iframe width=\"800\" height=\"350\" frameborder=\"0\" src=\"http://pythontutor.com/iframe-embed.html#code=x%20%3D%205%0Ay%20%3D%20x%0Ay%20%3D%20y%20%2B%203%20%0Aprint%28x,%20y%29&#x26;codeDivHeight=400&#x26;codeDivWidth=350&#x26;cumulative=false&#x26;curInstr=0&#x26;heapPrimitives=true&#x26;origin=opt-frontend.js&#x26;py=3&#x26;rawInputLstJSON=%5B%5D&#x26;textReferences=false\"> </iframe>\n<div class=\"my2\"></div>\n<iframe width=\"800\" height=\"400\" frameborder=\"0\" src=\"https://pythontutor.com/iframe-embed.html#code=x%20%3D%20%5B5,%206,%207%5D%0Ay%20%3D%20x%0Ay%5B0%5D%20%3D%20y%5B0%5D%20%2B%203%0Aprint%28x%5B0%5D,%20y%5B0%5D%29&#x26;codeDivHeight=400&#x26;codeDivWidth=350&#x26;cumulative=false&#x26;curInstr=0&#x26;heapPrimitives=true&#x26;origin=opt-frontend.js&#x26;py=3&#x26;rawInputLstJSON=%5B%5D&#x26;textReferences=false\"> </iframe>\n<div class=\"my2\"></div>\n<iframe width=\"800\" height=\"400\" frameborder=\"0\" src=\"https://pythontutor.com/iframe-embed.html#code=def%20example%28x%29%3A%0A%20%20%20%20x%20%3D%20x%20*%205%0A%0Ax%20%3D%205%0Aexample%28x%29%20%0Aprint%28x%29&#x26;codeDivHeight=400&#x26;codeDivWidth=350&#x26;cumulative=false&#x26;curInstr=0&#x26;heapPrimitives=true&#x26;origin=opt-frontend.js&#x26;py=3&#x26;rawInputLstJSON=%5B%5D&#x26;textReferences=false\"> </iframe>\n<div class=\"my2\"></div>\n<iframe width=\"800\" height=\"500\" frameborder=\"0\" src=\"https://pythontutor.com/iframe-embed.html#code=def%20example%28x%29%3A%0A%20%20%20%20x%5B0%5D%20%3D%20x%5B0%5D%20*%205%0A%0Ax%20%3D%20%5B5,%206,%207%5D%0Aexample%28x%29%0Aprint%28x%5B0%5D%29&#x26;codeDivHeight=400&#x26;codeDivWidth=350&#x26;cumulative=false&#x26;curInstr=0&#x26;heapPrimitives=true&#x26;origin=opt-frontend.js&#x26;py=3&#x26;rawInputLstJSON=%5B%5D&#x26;textReferences=false\"> </iframe>\n<div class=\"my2\"></div>\n<h2>What modifies a list?</h2>\n<ul>\n<li>Assigning a value to an element using its index.\n<python>a = [1, 2, 3]\na[0] = 5\n</python>\n</li>\n<li>Using the slice assignment to modify the elements of a list.\n<python>a = [1, 2, 3]\na[:2] = [4, 5]\n</python>\n</li>\n<li>Using methods like <code>append(), insert(), remove() , pop(), sort()</code>, etc.</li>\n</ul>\n<h2>What does not modify a list?</h2>\n<ul>\n<li>Slicing! It is a useful tool to create new lists out of an existing lists.\n<python>a = [1, 2, 3]\nb = a[:]  # makes a copy of a\nprint(a is b)  # False! The two variables refer to different objects.\n</python>\n</li>\n<li>The <inline-code>+</inline-code> and <inline-code>*</inline-code> operators create a new list\n<python>a = [1, 2, 3]\nb = a  # does not copy, just a new name for same list\nb = b + [4]  # b now refers to a new list [1, 2, 3, 4]\n             # a still refers to [1, 2, 3]\nprint(a is b)  # False\n</python>\n</li>\n</ul>\n<p><img style=\"display: block; margin: 3em auto; width: 15%;\" src=\"../assets/divider.svg\"></p>\n<h1>Packing vs Unpacking</h1>\n<p>When we create a string, a list, or a tuple, we are packing several elements into a single object.</p>\n<python>s = \"cat\"\nmy_list = [5, 'a']\nmy_tuple = (0, 3, 7)\n</python>\n<p>Unpacking allows us to assign values in a string/list/tuple to multiple variables.<br>\nWe must know the exact length of the string/list/tuple.</p>\n<python>s = \"cat\"\na, b, c = s\n# a, b and c are all strings\nprint(a)  # c\nprint(b)  # a\nprint(c)  # t\n\nmy_list = [5, 'a']\nx, y = my_list\nprint(x)  # 5\nprint(y)  # a\n\n# Parentheses are optional in this context.\nmy_tuple = 0, 3, 7\nx, y, z = my_tuple\nprint(x)  # 0\nprint(y)  # 3\nprint(z)  # 7\n\n# Variables must match number of elements\ntup = 1, 2, 3 \nx, y = tup\n# ValueError: too many values to unpack (expected 2)\n</python>\n<h2>Multiple assignment using packing/unpacking on same line</h2>\n<python># We are creating a tuple on the right side and \n# unpacking it into 3 variables.\ncity, population, area = 'Montreal', 1704694, 431.5\nprint(city)  # Montreal\nprint(population)  # 1704694\nprint(area)  # 431.5\n</python>\n<h2>Returning a tuple from a function and unpacking</h2>\n<python>def min_max(mylist):\n    # Return a tuple of two elements\n    return min(mylist), max(mylist)\n    \n    \n# Unpack the returned tuple into 2 variables\nx, y = min_max([2, -3, 10, 20])\nprint(x)  # -3\nprint(y)  # 20\n</python>\n<p><img style=\"display: block; margin: 3em auto; width: 15%;\" src=\"../assets/divider.svg\"></p>\n<h1>Sets</h1>\n<ul>\n<li>A set is a an unordered collection of <i>immutable</i> objects.</li>\n<li>A set always contains unique elements, unlike lists and tuples which allow duplicates.</li>\n<li>A set is unordered i.e. we cannot use indexing or slicing on a set object</li>\n</ul>\n<python>numbers = {1, 2, 3}\nprint(numbers)  # {1, 2, 3}\nprint(type(numbers))  # &#x3C;class 'set'>\n\n# only unique values are kept\nnumbers = {1, 2, 3, 1, 3}\nprint(numbers)  # {1, 2, 3}\nprint(len(numbers))  # 3\n</python>\n<h2>Other ways to create a set</h2>\n<python># a set can be created from any sequence\n# such as list, tuple or a string\nthings = set([10, 42, \"apple\", 42])\nprint(things)  # {'apple', 10, 42}\n\nword = \"pineapple\"\nletters = set(word)\nprint(letters)  # {'p', 'n', 'l', 'i', 'e', 'a'}\n\n# create an empty set\nempty_set = set()\nprint(len(empty_set))  # 0\n\n# This does not create an empty set!\nempty_dictionary = {}\nprint(type(empty_dictionary))  # &#x3C;class 'dict'>\n</python>\n<h2>Set elements must be immutable</h2>\n<p>A set can contain <inline-code>int</inline-code>, <inline-code>float</inline-code>, <inline-code>str</inline-code>, <inline-code>bool</inline-code> and <inline-code>tuple</inline-code> objects because they are all immutable.</p>\n<p>But a set cannot contain a list because lists are mutable.</p>\n<python># tuples are immutable so allowed in set\npoints = {(1, 1), (3, 10), (3, 10)}\nprint(points)  \n# {(3, 10), (1, 1)}\n\n# lists are mutable so not allowed\npoints = {[1, 1], [3, 10], [3, 10]}  \n# TypeError: unhashable type: 'list'\n</python>\n<h2>Set operators and methods</h2>\n<python># set.add(x):\n#   Adds an element x to the set if x does not exist in the set. \n#   Does not return anything.\nnumbers = {1, 2, 3}\nnumbers.add(20)\nprint(numbers)  # {1, 2, 3, 20}\n\nnumbers.add(3)\nprint(numbers)  # {1, 2, 3, 20}\n\n\n# set.remove(x):\n#   Remove an element x from the set. Does not return anything.\n#   Throws KeyError if element x is not present in the set.\nnumbers = {1, 2, 3}\nnumbers.remove(2)\nprint(numbers)  # {1, 3}\nnumbers.remove(5)  # KeyError: 5\n\n\n# in/not in operators to check if element exists in a set\nnumbers = {1, 2, 3}\nprint(2 in numbers)  # True\nprint(5 not in numbers)  # True\n\nshapes = {'circle', 'square'}\nprint(\"circle\" in shapes)  # True\n\n\n# For the following methods, suppose A and B are sets.\n\n# A.intersection(B):\n#    Returns a new set that contains elements that are\n#    present in both A and B   \nodd = {3, 5, 7, 9, 25}\nsquares = {4, 9, 25, 36}\nodd_squares = odd.intersection(squares)\nprint(odd_squares)  # {9, 25}\n\n# Intersection can also be done using operator &#x26;\nodd_squares = odd &#x26; squares\nprint(odd_squares)  # {9, 25}\n\n\n# A.union(B):\n#    Returns a new set that contains elements that are\n#    present in  A or B or both\n\nx = {1, 2, 3}\ny = {2, 3, 5}\nall_numbers = x.union(y)\nprint(all_numbers)  # {1, 2, 3, 5}\n\n# Same above but using an operator |\nall_numbers = x | y\nprint(all_numbers)  # {1, 2, 3, 5}\n\n\n# A.difference(B):\n#   Returns a new set that contains elements that are\n#   present only in A but not in B\nx = {1, 2, 3}\ny = {2, 3, 5}\ndiff = x.difference(y)\nprint(diff)  # {1}\n\n# Same as above but using operator -\ndiff = x - y\nprint(diff)  # {1}\n\n# All of the above methods work the same when elements are\n# of other types such as strings. \n</python>\n<h2>Sets cannot be indexed or sliced because they are not ordered</h2>\n<python>primes = {2, 3, 5, 7, 11}\nprimes[4]  # TypeError: 'set' object is not subscriptable\n</python>\n<p>But you can use for loop to iterate over the elements:</p>\n<python># The order in which items will be printed is not defined\n# because sets are not ordered\nnumbers = {10, 1, 5, 20}\nfor n in numbers:\n    print(n)\n</python>\n<output>1\n10\n20\n5\n</output>\n<h2>Why use sets?</h2>\n<ul>\n<li>Set are faster than lists and tuples, when inserting, removing and searching elements.</li>\n<li>When ordering of elements is important or when elements are mutable, use lists or tuples</li>\n<li>When only unique immutable elements need to be stored, use sets.</li>\n</ul>\n<p><img style=\"display: block; margin: 3em auto; width: 15%;\" src=\"../assets/divider.svg\"></p>\n<h1>Dictionaries</h1>\n<h2>Motivation</h2>\n<p>Suppose we would like to store the following enrollment data:</p>\n<div class=\"my2\">\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>semester</th><th>no. of students</th></tr></thead><tbody><tr><td>F2017</td><td>816</td></tr><tr><td>W2018</td><td>613</td></tr><tr><td>F2018</td><td>709</td></tr><tr><td>W2019</td><td>590</td></tr><tr><td>F2019</td><td>744</td></tr></tbody></table></div>\n<p>We can do this using two lists for the two columns:</p>\n<python>semesters = ['F2017', 'W2018', 'F2018', 'W2019', 'F2019']\nstudents = [816, 613, 709, 590, 744]\n</python>\n<p>What should we do if we want to add new data?</p>\n<python>semesters.append(\"F2020\")\nstudents.append(550)\n# ['F2017', 'W2018', 'F2018', 'W2019', 'F2019', 'F2020']\n# [816, 613, 709, 590, 744, 550]\n</python>\n<p>What if we want to modify the value for a specific semester?</p>\n<python>idx = semesters.index(\"W2018\")\nstudents[idx] = 600\n</python>\n<p>What we if try to add an entry for a semester that already exists?<br>\nList allows duplicates so it does not check if a semester already exists.</p>\n<h3>Use a dictionary!</h3>\n<ul>\n<li>You can think of an element of a dictionary as a pair of objects:\n<ul>\n<li>The first object of the pair is called a <sc>key</sc>.</li>\n<li>The second object is referred to as the <sc>value</sc>.</li>\n</ul>\n</li>\n<li>A dictionary is called a <i>mapping</i> type because it maps key objects to value objects.</li>\n<li>Elements in a dictionary are often called <i>items</i>.</li>\n</ul>\n<python># A dictionary is created using a sequence of key-value pairs\nenrollment = {'F2017': 816, 'W2018': 613, 'F2018': 709,\n              'W2019': 590, 'F2019': 744}\nprint(type(enrollment))  # &#x3C;class 'dict'>\n\n# Number of key-value pairs\nprint(len(enrollment))  # 5\n\n# This is an empty dictionary, not a set!\nempty_dict = {}\nprint(len(empty_dict)) # 0\n</python>\n<h2>Note on keys and values</h2>\n<ul>\n<li>Keys\n<ul>\n<li>Have to be immutable objects.</li>\n<li>Have to be unique in a dictionary. A dictionary cannot contain two items with the same key.</li>\n</ul>\n</li>\n<li>Values\n<ul>\n<li>Values can be of any type; both mutable and immutable values are allowed.</li>\n<li>Many keys can map to the same value. i.e. values need not be unique.</li>\n</ul>\n</li>\n</ul>\n<h2>Dictionary Lookup</h2>\n<p>With lists, we can access an element of the list through its index.</p>\n<p>With dictionaries, we can access a value stored in the dictionary through the key associated with it.</p>\n<python>enrollment = {'F2017': 816, 'W2018': 613, 'F2018': 709,\n              'W2019': 590, 'F2019': 744}\n\n\nnum_students = enrollment[\"F2018\"]\nprint(num_students)  # 709\n\n# Key must exist in the dictionary if we want to access its value\nprint(enrollment[\"F2020\"])  # KeyError: 'F2020'\n</python>\n<h2>Adding an item</h2>\n<p>We can add a new item by specifying a key and a value: <inline-code>dictionary[key] = value</inline-code></p>\n<python>\n# A dictionary is created using a sequence of key-value pairs\nenrollment = {'F2018': 709, 'W2019': 590, 'F2019': 744}\n\n\n# add an item\nenrollment[\"F2020\"] = 800\n\n# add another item\nenrollment[\"W2020\"] = 900\n\nprint(enrollment)\n# {'F2018': 709, 'W2019': 590, 'F2019': 744, 'F2020': 800, 'W2020': 900}\n\n# change an existing item\nenrollment[\"F2018\"] = 700\n\nprint(enrollment)\n# {'F2018': 700, 'W2019': 590, 'F2019': 744, 'F2020': 800, 'W2020': 900}\n</python>\n<h2>Removing an item</h2>\n<p>We can delete an item using the following syntax:<br>\n<inline-code>del dictionary[key]</inline-code></p>\n<python>enrollment = {'F2018': 709, 'W2019': 590, 'F2019': 744}\n\n\ndel enrollment[\"F2019\"]\n\nprint(enrollment)\n# {'F2018': 709, 'W2019': 590}\n\ndel enrollment[\"F2020\"]\n# KeyError: 'F2020'\n\n</python>\n<h2>Examples</h2>\n<p>What will be printed in the following examples?</p>\n<div class=\"flex\"><div class=\"flexc px1\"><python>d = {'x' : 0, 'y' : 1, 'z' : 2} \nx = d['y']\nprint(x)\n</python><output>1\n</output></div><div class=\"flexc px1\"><python>d = {'x' : 0, 'y' : 1, 'z' : 2} \nx = d[0]\nprint(x)\n</python><output>KeyError: 0\n</output></div></div>\n<h2>Check for membership</h2>\n<p>We can check if a key is part of a dictionary using the <inline-code>in</inline-code> and <inline-code>not in</inline-code> operators.</p>\n<python>d = {'x' : 0, 'y' : 1, 'z' : 2} \nprint('x' in d) #  True \nprint(0 in d) #  False\nprint(0 not in d) #  True\n</python>\n<h2>Iterating through a dictionary</h2>\n<p>We can use a for loop to iterate through all the keys in a dictionary.</p>\n<python>enrollment = {'F2018': 709, 'W2019': 590, 'F2019': 744}\n\nfor key in enrollment:\n    print(key, \"->\", enrollment[key])\n</python>\n<output>F2018 -> 709\nW2019 -> 590\nF2019 -> 744\n</output>\n<h2>Functions and methods for dictionaries</h2>\n<python># dict(L): creates and returns a dictionary using a list L of tuples, \n#   where each tuple is of length 2 in form of (key, value).\npairs = [(\"Montreal\", 1.78), (\"Rome\", 2.87), (\"Tokyo\", 9.27)]\nd = dict(pairs)\nprint(d)\n#  {'Montreal': 1.78, 'Rome': 2.87, 'Tokyo': 9.27}\nprint(d[\"Rome\"])\n# 2.87\n\n\n# dict.keys(): returns a iterable (sequence) of all keys\nkeys = list(d.keys())\nprint(keys)  # ['Montreal', 'Rome', 'Tokyo']\n\n\n# dict.values(): returns a iterable (sequence) of all values\nvalues = list(d.values())\nprint(values)  # [1.78, 2.87, 9.27]\n\n\n# dict.items(): returns a iterable (sequence) of tuples (key, value) \n#   for all items in the dictionary\nd = {'Montreal': 1.78, 'Rome': 2.87, 'Tokyo': 9.27}\npairs = list(d.items())\nprint(pairs)\n# [('Montreal', 1.78), ('Rome', 2.87), ('Tokyo', 9.27)]\n</python>\n<p>For more methods, help <inline-code>help(dict)</inline-code>.</p>\n<p>Using the above methods to iterate over a dictionary:</p>\n<python>d = {'Montreal': 1.78, 'Rome': 2.87, 'Tokyo': 9.27}\ntotal = 0\nfor val in d.values():\n    total += val\n\nprint(total)  # 13.92\n</python>\n<p>Making use of tuple unpacking in the for loop:</p>\n<python>d = {'Montreal': 1.78, 'Rome': 2.87, 'Tokyo': 9.27}\n\n# d.items() returns a sequence of key-value tuples\nfor tup in d.items():\n    key = tup[0]\n    val = tup[1]\n    print(key, \"->\", val)\n\n# Montreal -> 1.78\n# Rome -> 2.87\n# Tokyo -> 9.27\n\n\n# Unpack tuple into two variables: key and val\nfor key, val in d.items():\n    print(key, \"->\", val)\n\n# Montreal -> 1.78\n# Rome -> 2.87\n# Tokyo -> 9.27\n</python>\n<p><img style=\"display: block; margin: 3em auto; width: 15%;\" src=\"../assets/divider.svg\"></p>"}},"__N_SSG":true}