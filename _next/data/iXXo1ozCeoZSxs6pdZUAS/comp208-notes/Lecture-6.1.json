{"pageProps":{"titles":["2.1 — Programming Basics","2.2 — Variables, Arithmetic & String operations","2.3 — Function Calls, Expressions","3.1 — Defining functions, Errors & Debugging","3.2 — Boolean Expressions, Comparison & Logical Operators","3.3 — Conditional execution using if statement","3.4 — for loop & String indexing, slicing","Python Style Guide","4.1 — Escape Characters & Controlling print()","4.2 — String methods & in operator","4.3 — while statement & Nested loops","4.4 — return statement & Importing modules","5.1 — Scope of Variables","5.2 — Lists & List Operations","5.3 — List Functions & Methods","5.4 — Tuples","6.1 — Object Identity, Immutability, Unpacking","6.2 — Sets","6.3 — Dictionaries","7.1 — Nested data structures & comparisons","7.2 — Iterables & comprehensions","7.3 — Reading and writing files","8.1 — Default arguments & Modules","8.2 — Handling Exceptions","8.3 — Object Oriented Programming (OOP)"],"slugs":["Lecture-2.1","Lecture-2.2","Lecture-2.3.1","Lecture-3.1","Lecture-3.2","Lecture-3.3","Lecture-3.4","style-guide","Lecture-4.1","Lecture-4.2","Lecture-4.3","Lecture-4.4","Lecture-5.1","Lecture-5.2","Lecture-5.3","Lecture-5.4","Lecture-6.1","Lecture-6.2","Lecture-6.3","Lecture-7.1","Lecture-7.2","Lecture-7.3","Lecture-8.1","Lecture-8.2","Lecture-8.3"],"post":{"title":"6.1 — Object Identity, Immutability, Unpacking","slug":"Lecture-6.1","content":"<h1>Object Identity</h1>\n<ul>\n<li>Each object is assigned an <sc>ID</sc> at its creation (think of a memory address).</li>\n<li>This ID is unique and constant for this object as long as the object exists.</li>\n<li>The built-in function <inline-code>id()</inline-code> can be used to retrieve the ID of an object.</li>\n</ul>\n<python>x = 1234\ny = x\n\n# x and y both point to the same object, \n# therefore the IDs are the same.\nprint(id(x) == id(y))  # True\n\n# x and y point to two different objects, \n# therefore we expect x and y to have different IDs.\nx = 1234\ny = 5678\nprint(id(x) == id(y))  # False\n\n# x and y point to two different objects (with the same value),\n# therefore we expect x and y to have different IDs.\nx = int(\"1234\")  # integer 1234\ny = int(\"12\" + \"34\")  # integer 1234\n\nprint(id(x) == id(y))  # False\n</python>\n<h2>Identity operators</h2>\n<ul>\n<li><inline-code>is</inline-code> and <inline-code>is not</inline-code> are comparison operators used to determine if the two operands have the same identity (i.e refer to the same object)</li>\n<li>Note that this is NOT the same thing as checking for equality using <inline-code>==</inline-code> operator!\n<ul>\n<li>Using <inline-code>is</inline-code> operator means: are two variables referring to one and the same object?</li>\n<li>Using <inline-code>==</inline-code> operator means: are two variables referring to objects that contain same data?</li>\n</ul>\n</li>\n</ul>\n<div class=\"flex\" style=\"width: 120%; margin-left: -3em;\"><python>x = int(\"1234\")  # 1234\ny = int(\"12\" + \"34\")  # 1234\nz = x \nprint(x == y)  # True\nprint(x == z)  # True\n</python><python>x = int(\"1234\")  # 1234\ny = int(\"12\" + \"34\")  # 1234\nz = x \nprint(x is y)  # False\nprint(x is z)  # True\n</python><python>x = 1234 \ny = 5678\nprint(x is y)  # False\nprint(x == y)  # False\nprint(x is not y)  # True\n</python></div>\n<h1>Mutable vs Immutable objects</h1>\n<p><sc>Immutable</sc>: the content of the object cannot be changed after the object has been created.</p>\n<ul>\n<li>e.g. <inline-code>str</inline-code>, <inline-code>int</inline-code>, <inline-code>float</inline-code>, <inline-code>tuple</inline-code></li>\n</ul>\n<p><sc>Mutable</sc>: the content of the object can be changed after its creation without changing its identity.</p>\n<ul>\n<li>e.g. <inline-code>list</inline-code>, <inline-code>dict</inline-code>, <inline-code>set</inline-code></li>\n</ul>\n<h2>Strings are immutable</h2>\n<p>Unlike lists, we cannot use the square brackets to modify a character in the string.<br>\nFor example:</p>\n<python>s = \"cats\"\ns[0] = \"r\"  # TypeError: 'str' object does not support item assignment\n</python>\n<p>All strings operations that seem to change a string actually <i>create</i> a new string.</p>\n<python>s = \"cat\"\nt = s\nprint(\"Before:\", s is t)\ns = s.replace('c','r')\nprint(\"After:\", s is t)\nprint(\"s:\", s)\nprint(\"t:\", t)\n</python>\n<output>Before: True\nAfter: False\ns: rat\nt: cat\n</output>\n<h2>Lists are mutable</h2>\n<p>The following code does not create a copy of the list <inline-code>x</inline-code>.<br>\nIt simply create a new variable name for the same list.</p>\n<python>x = [1, 2, 3]\ny = x  # new name y for same list\n\nprint(x is y)  # True\n</python>\n<p>Let us see some implications of this.</p>\n<p>In the following illustrations, think about what is modified.</p>\n<ul>\n<li>Whether a variable changes its value i.e. the variable refers to a different value</li>\n<li>Whether a list object is modified i.e. some element of the list is changed.</li>\n</ul>\n<iframe width=\"800\" height=\"350\" frameborder=\"0\" src=\"https://pythontutor.com/iframe-embed.html#code=x%20%3D%205%0Ay%20%3D%20x%0Ay%20%3D%20y%20%2B%203%20%0Aprint%28x,%20y%29&#x26;codeDivHeight=400&#x26;codeDivWidth=350&#x26;cumulative=false&#x26;curInstr=0&#x26;heapPrimitives=true&#x26;origin=opt-frontend.js&#x26;py=3&#x26;rawInputLstJSON=%5B%5D&#x26;textReferences=false\"> </iframe>\n<div class=\"my2\"></div>\n<iframe width=\"800\" height=\"400\" frameborder=\"0\" src=\"https://pythontutor.com/iframe-embed.html#code=x%20%3D%20%5B5,%206,%207%5D%0Ay%20%3D%20x%0Ay%5B0%5D%20%3D%20y%5B0%5D%20%2B%203%0Aprint%28x%5B0%5D,%20y%5B0%5D%29&#x26;codeDivHeight=400&#x26;codeDivWidth=350&#x26;cumulative=false&#x26;curInstr=0&#x26;heapPrimitives=true&#x26;origin=opt-frontend.js&#x26;py=3&#x26;rawInputLstJSON=%5B%5D&#x26;textReferences=false\"> </iframe>\n<div class=\"my2\"></div>\n<iframe width=\"800\" height=\"400\" frameborder=\"0\" src=\"https://pythontutor.com/iframe-embed.html#code=def%20example%28x%29%3A%0A%20%20%20%20x%20%3D%20x%20*%205%0A%0Ax%20%3D%205%0Aexample%28x%29%20%0Aprint%28x%29&#x26;codeDivHeight=400&#x26;codeDivWidth=350&#x26;cumulative=false&#x26;curInstr=0&#x26;heapPrimitives=true&#x26;origin=opt-frontend.js&#x26;py=3&#x26;rawInputLstJSON=%5B%5D&#x26;textReferences=false\"> </iframe>\n<div class=\"my2\"></div>\n<iframe width=\"800\" height=\"500\" frameborder=\"0\" src=\"https://pythontutor.com/iframe-embed.html#code=def%20example%28x%29%3A%0A%20%20%20%20x%5B0%5D%20%3D%20x%5B0%5D%20*%205%0A%0Ax%20%3D%20%5B5,%206,%207%5D%0Aexample%28x%29%0Aprint%28x%5B0%5D%29&#x26;codeDivHeight=400&#x26;codeDivWidth=350&#x26;cumulative=false&#x26;curInstr=0&#x26;heapPrimitives=true&#x26;origin=opt-frontend.js&#x26;py=3&#x26;rawInputLstJSON=%5B%5D&#x26;textReferences=false\"> </iframe>\n<div class=\"my2\"></div>\n<h2>What modifies a list?</h2>\n<ul>\n<li>Assigning a value to an element using its index.\n<python>a = [1, 2, 3]\na[0] = 5\n</python>\n</li>\n<li>Using the slice assignment to modify the elements of a list.\n<python>a = [1, 2, 3]\na[:2] = [4, 5]\n</python>\n</li>\n<li>Using methods like <code>append(), insert(), remove() , pop(), sort()</code>, etc.</li>\n</ul>\n<h2>What does not modify a list?</h2>\n<ul>\n<li>Slicing! It is a useful tool to create new lists out of an existing lists.\n<python>a = [1, 2, 3]\nb = a[:]  # makes a copy of a\nprint(a is b)  # False! The two variables refer to different objects.\n</python>\n</li>\n<li>The <inline-code>+</inline-code> and <inline-code>*</inline-code> operators create a new list\n<python>a = [1, 2, 3]\nb = a  # does not copy, just a new name for same list\nb = b + [4]  # b now refers to a new list [1, 2, 3, 4]\n             # a still refers to [1, 2, 3]\nprint(a is b)  # False\n</python>\n</li>\n</ul>\n<h1>Packing vs Unpacking</h1>\n<p>When we create a string, a list, or a tuple, we are packing several elements into a single object.</p>\n<python>s = \"cat\"\nmy_list = [5, 'a']\nmy_tuple = (0, 3, 7)\n</python>\n<p>Unpacking allows us to assign values in a string/list/tuple to multiple variables.<br>\nWe must know the exact length of the string/list/tuple.</p>\n<python>s = \"cat\"\na, b, c = s\n# a, b and c are all strings\nprint(a)  # c\nprint(b)  # a\nprint(c)  # t\n\nmy_list = [5, 'a']\nx, y = my_list\nprint(x)  # 5\nprint(y)  # a\n\n# Parentheses are optional in this context.\nmy_tuple = 0, 3, 7\nx, y, z = my_tuple\nprint(x)  # 0\nprint(y)  # 3\nprint(z)  # 7\n\n# Variables must match number of elements\ntup = 1, 2, 3 \nx, y = tup\n# ValueError: too many values to unpack (expected 2)\n</python>\n<h2>Multiple assignment using packing/unpacking on same line</h2>\n<python># We are creating a tuple on the right side and \n# unpacking it into 3 variables.\ncity, population, area = 'Montreal', 1704694, 431.5\nprint(city)  # Montreal\nprint(population)  # 1704694\nprint(area)  # 431.5\n</python>\n<h2>Returning a tuple from a function and unpacking</h2>\n<python>def min_max(mylist):\n    # Return a tuple of two elements\n    return min(mylist), max(mylist)\n    \n    \n# Unpack the returned tuple into 2 variables\nx, y = min_max([2, -3, 10, 20])\nprint(x)  # -3\nprint(y)  # 20\n</python>\n<p><img style=\"display: block; margin: 3em auto; width: 15%;\" src=\"../assets/divider.svg\"></p>"}},"__N_SSG":true}