{"pageProps":{"titles":["2.1 — Programming Basics","2.2 — Variables, Arithmetic & String operations","2.3 — Function Calls, Expressions","3.1 — Defining functions, Errors & Debugging","3.2 — Boolean Expressions, Comparison & Logical Operators","3.3 — Conditional execution using if statement","3.4 — for loop & String indexing, slicing","Python Style Guide","4.1 — Escape Characters & Controlling print()","4.2 — String methods & in operator","4.3 — while statement & Nested loops","4.4 — return statement & Importing modules","5.1 — Scope of Variables","5.2 — Lists & List Operations","5.3 — List Functions & Methods","5.4 — Tuples","6.1 — Object Identity, Immutability, Unpacking","6.2 — Sets","6.3 — Dictionaries","7.1 — Nested data structures & comparisons","7.2 — Iterables & comprehensions","7.3 — Reading and writing files","8.1 — Default arguments & Modules","8.2 — Handling Exceptions","8.3 — Object Oriented Programming (OOP)"],"slugs":["Lecture-2.1","Lecture-2.2","Lecture-2.3.1","Lecture-3.1","Lecture-3.2","Lecture-3.3","Lecture-3.4","style-guide","Lecture-4.1","Lecture-4.2","Lecture-4.3","Lecture-4.4","Lecture-5.1","Lecture-5.2","Lecture-5.3","Lecture-5.4","Lecture-6.1","Lecture-6.2","Lecture-6.3","Lecture-7.1","Lecture-7.2","Lecture-7.3","Lecture-8.1","Lecture-8.2","Lecture-8.3"],"post":{"title":"8.2 — Handling Exceptions","slug":"Lecture-8.2","content":"<h1>Types of Errors</h1>\n<ul>\n<li>Syntax Errors: When syntax is incorrect such as wrong punctuations, invalid characters, indentation etc.\n<ul>\n<li>Program does not even run in this case.</li>\n</ul>\n</li>\n<li>Runtime Errors, also called <sc>Exceptions</sc>, occur when there is a problem in the program during execution.\n<ul>\n<li>All code executes until an exception occurs.</li>\n</ul>\n</li>\n<li>Semantic or Logic errors are said to occur when a program executes without a problem but does not produce correct output as expected.</li>\n</ul>\n<p>In Python, all exceptions are objects of some exception type.</p>\n<p>Common exceptions are:</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Exception Type</th><th>Meaning</th></tr></thead><tbody><tr><td>IndexError</td><td>index is out of range in a list or tuple</td></tr><tr><td>KeyError</td><td>Specified key does not appear in a dictionary</td></tr><tr><td>NameError</td><td>Specified local or global name does not exist</td></tr><tr><td>TypeError</td><td>Operation or function applied to an inappropriate type</td></tr><tr><td>ValueError</td><td>Operation or function applied to correct type but inappropriate value</td></tr><tr><td>ZeroDivisionError</td><td>Second operand of division or remainder operation is zero</td></tr></tbody></table>\n<python># Proof that IndexError, NameError etc are types.\n# We create objects of these types. \n# Though this example does not do anything useful :)\n>>> a = IndexError() # constructor of IndexError\n>>> print(a, type(a))\n &#x3C;class 'IndexError'>\n</python>\n<h2>Exception Traceback</h2>\n<p>Traceback is an error message that allows tracing an exception back to its origin</p>\n<div class=\"flex\"><python>def func():\n   return 5 / 0\n\ndef main():\n   return func()\n\nmain()\n</python><output>Traceback (most recent call last):\n  File \"myprogram.py\", line 7, in &#x3C;module>\n    main()\n  File \"myprogram.py\", line 5, in main\n    return func()\n  File \"myprogram.py\", line 2, in func\n    return 5 / 0\nZeroDivisionError: division by zero\n</output></div>\n<h2>Using <code>try</code> statement to handle errors</h2>\n<python>try:\n    # try-block: code that may cause runtime error\nexcept:\n    # except-block: handle the error here\n</python>\n<ul>\n<li>Identify a code that can potentially produce errors</li>\n<li>Put that code in <inline-code>try-block</inline-code>.</li>\n<li>Write code in <inline-code>except-block</inline-code> to handle the case when error occurs</li>\n</ul>\n<h3>Example:</h3>\n<p>Suppose we want to take a number from user input:</p>\n<python>number = float(input('Please enter a number: '))\n</python>\n<output>ValueError: could not convert string to float: 'abcd'\n</output>\n<p>Since we know that <inline-code>float()</inline-code> function throws the <inline-code>ValueError</inline-code>, we can handle that error as follows.</p>\n<python>try:\n   number = float(input('Please enter a number: '))\n   # the following line only executes when float() function\n   # worked i.e. it did not throw ValueError\n   print(\"You entered: \", number)  \nexcept ValueError:\n   print(\"Please enter valid number!\")\n</python>\n<p>There are two cases that may happen when we run the code above:</p>\n<div class=\"flex ml-2\"><div class=\"flexc\"><p></p><div class=\"sans\">No error occurs in try-block</div>\nexcept-block is not executed.<p></p><output>Please enter a number: -3.1415\nYou entered:  -3.1415\n</output></div><div class=\"flexc\"><p></p><div class=\"sans\">Error occurs in try-block</div>\nexcept-block is executed.<p></p><output>Please enter a number: abcd\nPlease enter valid number!\n</output></div></div>\n<h3>Example</h3>\n<p>Using try statement in a loop, ask user to input a number (float) until they enter a correct number.<br>\nYou can use a break statement in the try-block.</p>\n<output>Please enter a number: abcd\nInvalid number!\nPlease enter a number: -1.61\nCorrect number entered: -1.61\n</output>\n<python>while True: # Loop forever\n   try:\n       number = float(input('Please enter a number: '))\n       break  # Get out of the loop\n   except ValueError:\n       print('Invalid number!')\n\nprint(\"Correct number entered:\", number)\n</python>\n<h2>Uncaught exceptions are thrown as usual</h2>\n<p>If an exception occurs in try-block but it is not the same type as in the except part, the exception occurs as usual i.e. except-block is not executed and program crashes.</p>\n<python>student_grades = {\"Reza\": 90.0}\n\ntry:\n    name = input('Enter name: ')\n    grade = float(input(\"Enter grade to add: \"))\n    student_grades[name] += grade\n    print(student_grades)\nexcept ValueError:\n    print('Grade should be a number!')\n</python>\n<output>Enter name: Dev\nEnter grade to add: 5\nTraceback (most recent call last):\n  File \"myprogram.py\", line 20, in &#x3C;module>\n    student_grades[name] += grade\nKeyError: 'Dev'\n</output>\n<h2>Catching multiple exceptions</h2>\n<p>Except blocks can be chained to handle multiple exceptions that may occur in try-block.</p>\n<p>Depending on the exception that occurs, only one of the except-blocks executes. Others are skipped.</p>\n<python>student_grades = {\"Reza\": 90.0}\n\ntry:\n    name = input('Enter name: ')\n    grade = float(input(\"Enter grade to add: \"))\n    student_grades[name] += grade\n    print(student_grades)\nexcept ValueError:\n    print('Grade should be a number!')\nexcept KeyError:\n    print(name, \"was not found.\")\n</python>\n<div class=\"flex\" style=\"width: 110%; margin-left: -2em;\"><div class=\"flexc\"><p><span class=\"sans\">No error</span></p><output>Enter name: Reza\nEnter grade to add: 5\n{'Reza': 95.0}\n</output></div><div class=\"flexc\"><p><span class=\"sans\">ValueError</span></p><output>Enter name: Reza\nEnter grade to add: 10x\nGrade should be a number!\n</output></div><div class=\"flexc\"><p><span class=\"sans\">KeyError</span></p><output>Enter name: Dev\nEnter grade to add: 5\nDev was not found.\n</output></div></div>\n<h2>Default except block</h2>\n<p>We can have a default except block without any exception type to handle exception of any kind.<br>\nAgain, only one of the except-blocks executes at any time.</p>\n<div class=\"flex\" style=\"width: 110%; margin-left: -2em;\"><python>student_grades = {\"Reza\": 90.0}\n\ntry:\n    name = input('Enter name: ')\n    grade = float(input(\"Enter grade to add: \"))\n    student_grades[name] += grade\n    print(no_such_variable)  # error here\nexcept ValueError:\n    print('Grade should be a number!')\nexcept KeyError:\n    print(name, \"was not found.\")\nexcept:\n    print(\"Some error occured.\")\n</python><output>Enter name: Reza\nEnter grade to add: 5\nSome error occured.\n</output></div>\n<p>In general it is <i>not a good practice</i> to catch all errors using a default block.<br>\nInstead, specific errors should be handled explicitly by using a exception type.</p>\n<h2><inline-code>finally</inline-code> block</h2>\n<p>We can have an optional <inline-code>finally</inline-code> block in a <inline-code>try</inline-code> statement; it is always executed whether an exception occurs in <inline-code>try</inline-code> block or not. It is useful to clean up resources (e.g. closing a file), which needs to be done even when exceptions occur.</p>\n<python>def read_matrix(filename):\n    data = []\n    fobj = open(filename, \"r\")\n\n    try:\n        for line in fobj:\n            data.append([float(word.strip()) for word in line.split()])\n    except ValueError: # Something wrong with file e.g. string instead of a number\n        print('Error: Invalid file format!')\n        return None\n    finally:\n        print('Closing the file...')\n        fobj.close()\n    \n    print(\"All done.\")\n    return data\n\n\nmatrix = read_matrix('matrixdata.txt')\nprint(matrix)\n</python>\n<p>For above example, download the file <inline-code>matrixdata.txt</inline-code> from Ed Lesson and keep it in the same folder as the program.</p>\n<h2>When to use try statement</h2>\n<ul>\n<li>It is a bad practice to use a try/except to “hide” bugs in the program!</li>\n<li>try/except should be used when we know that a specific error may occurs and there is no other way to handle it</li>\n</ul>\n<div class=\"flex wfc ml-2\"><div class=\"flexc mr2\"><p><span class=\"sans\">Good practice</span></p><python>try:\n    number = float(input(\"Enter a number: \"))\nexcept ValueError:\n    print('Number is not valid!')\n</python><p>because there is no other better way to check if a string contains a valid number.</p></div><div class=\"flexc\"><p><span class=\"sans\">Not a good practice</span></p><python>student_grades = {\"Reza\": 90.0}\ntry:\n    name = input('Enter name: ')\n    student_grades[name] += 10\nexcept KeyError:\n    print(name, \"was not found.\")\n</python><p>because there is a another way to do this:</p><python>student_grades = {\"Reza\": 90.0}\n\nname = input('Enter name: ')\n\nif name in student_grades:\n    student_grades[name] += 10\nelse:\n    print(name, \"was not found.\")\n</python></div></div>\n<h2>Where do Exceptions come from?</h2>\n<p>We can “raise” or throw an exception from our code to tell Python that an unexpected case or error has occurred.</p>\n<p>For example, we can redefine <inline-code>euclidean_distance</inline-code> function to raise a <inline-code>ValueError</inline-code> if length of any argument list is not 2.</p>\n<python>def euclidean_distance(p1, p2):\n    \"\"\"\n    Computes Euclidean distance between two 2D points.\n\n    Args:\n       p1: list/tuple of length 2\n       p2: list/tuple of length 2\n\n    Returns: the euclidean distance as a float\n\n    Raises:\n       ValueError if length of arguments is not 2\n    \"\"\"\n    if (not isinstance(p1, (list, tuple))\n        or not isinstance(p1, (list, tuple))\n        or len(p1) != 2\n        or len(p2) != 2):\n        raise ValueError(\"Points must be lists or tuples of length 2.\")\n\n    d = (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n    return d ** 0.5\n\n\ndist = euclidean_distance([1, 1], [2, 3])\nprint(dist)\n\ndist = euclidean_distance(1, [2, 3])\nprint(dist)\n</python>\n<output>2.23606797749979\nValueError: Points must be lists or tuples of length 2.\n</output>\n<h3>Example:</h3>\n<p>How exceptions are raised in Python modules?<br>\nOpen the following link and search for <inline-code>raise</inline-code>:\n<a href=\"https://github.com/python/cpython/blob/main/Lib/random.py\">https://github.com/python/cpython/blob/main/Lib/random.py</a></p>\n<p><img style=\"display: block; margin: 3em auto; width: 15%;\" src=\"../assets/divider.svg\"></p>"}},"__N_SSG":true}