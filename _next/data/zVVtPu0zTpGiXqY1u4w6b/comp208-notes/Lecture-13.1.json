{"pageProps":{"allSlugs":[["Lecture-1",[{"title":"1 — Programming Basics","slug":"Lecture-1"}]],["Lecture-2.1",[{"title":"2.1 — Variables, Arithmetic & String operations","slug":"Lecture-2.1"}]],["Lecture-2.2",[{"title":"2.2 — Defining functions, Errors & Debugging","slug":"Lecture-2.2"}]],["Lecture-3.1",[{"title":"3.1 — Order of Expression Evaluation, Comparing Values, Conditional Execution","slug":"Lecture-3.1"}]],["Lecture-3.2",[{"title":"3.2 — if statement, for loop, Indexing & Slicing Strings","slug":"Lecture-3.2"}]],["Lecture-4.1",[{"title":"4.1 — return vs. print, while statement, Modules","slug":"Lecture-4.1"}]],["Lecture-4.2",[{"title":"4.2 — String methods, break & continue statements","slug":"Lecture-4.2"}]],["Lecture-5.1",[{"title":"5.1 — Controlling print(), Nested Loops, Lists","slug":"Lecture-5.1"}]],["Lecture-5.2",[{"title":"5.2 — Scope of variables, List operations","slug":"Lecture-5.2"}]],["Lecture-6.1",[{"title":"6.1 — Tuples, Immutable objects, Sets","slug":"Lecture-6.1"}]],["Lecture-6.2",[{"title":"6.2 — More list & set operations, Dictionaries","slug":"Lecture-6.2"}]],["Lecture-7.1",[{"title":"7.1 — Iterables, Unpacking, Nested Lists","slug":"Lecture-7.1"}]],["Lecture-7.2",[{"title":"7.2 — Nested data structures, Comprehensions, Modules","slug":"Lecture-7.2"}]],["Lecture-8.1",[{"title":"8.1 — Nested list comprehensions, Reading & Writing Files","slug":"Lecture-8.1"}]],["Lecture-8.2",[{"title":"8.2 — Shallow vs. deep copy, Handling exceptions","slug":"Lecture-8.2"}]],["Lecture-9.1",[{"title":"9.1 — Object Oriented Programming (OOP)","slug":"Lecture-9.1"}]],["Lecture-9.2",[{"title":"9.2 — Keyword arguments, More on OOP","slug":"Lecture-9.2"}]],["Lecture-10.1",[{"title":"10.1 — NumPy","slug":"Lecture-10.1"}]],["Lecture-10.2",[{"title":"10.2 — Plotting using Matplotlib, More Numpy","slug":"Lecture-10.2"}]],["Lecture-11.1",[{"title":"11.1 — More Numpy, Linear algebra, Random numbers","slug":"Lecture-11.1"}]],["Lecture-11.2",[{"title":"11.2 — Interpolation & Curve fitting","slug":"Lecture-11.2"}]],["Lecture-12.1",[{"title":"12.1 — System of Linear Equations, Numerical Integration","slug":"Lecture-12.1"}]],["Lecture-12.2",[{"title":"12.2 — Root Finding","slug":"Lecture-12.2"}]],["Lecture-13.1",[{"title":"13.1 — Binary Search, Sorting","slug":"Lecture-13.1"}]],["Lecture-13.2",[{"title":"13.2 — Root-finding & Miscellaneous Topics","slug":"Lecture-13.2"}]]],"post":{"slug":"Lecture-13.1","content":"<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"binary-search-algorithm\">Binary search algorithm</h2><p>We have seen examples which perform linear search using a loop:</p><python>def linear_search(sequence, target):\n    for index in range(len(sequence)):\n        if sequence[index] == target:\n            return index\n\n    return -1  # Not found\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"\"></h2><ul>\n<li>Binary search is a faster algorithm to search an item in a sequence, provided the sequence is <i>sorted</i>.</li>\n<li>Binary search is similar to looking up a word in an English dictionary. Suppose we are looking for the word “doctor”\n<ul>\n<li>We flip pages in the dictionary to find the “d” section but we may end up a little further to the right, say at “f” section.</li>\n<li>Then we flip pages to the left and may end up at “da” section.</li>\n<li>Then we flip pages to the right towards “do” and so on…</li>\n<li>At each step, we decrease the number of pages to search.</li>\n<li>The process works because the dictionary is sorted in alphabetical order.</li>\n</ul>\n</li>\n</ul></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-1\"></h2><p><b class=\"sans\">Visualize the binary search algorithm</b></p><iframe width=\"900\" height=\"600\" frameborder=\"0\" style=\"background-color: white;\" src=\"https://observablehq.com/embed/@d3vp/binary-search-algorithm?cells=view%2Cviewof+sequence%2Cviewof+item_to_search%2Cbuttons\"></iframe></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-2\"></h2><p><b class=\"sans\">Implementation</b></p><python>def binary_search(sequence, target):\n    low = 0\n    high = len(sequence) - 1\n\n    while low &#x3C;= high:\n        middle = (low + high) // 2  # floor division\n\n        if sequence[middle] &#x3C; target:\n            low = middle + 1\n        elif sequence[middle] > target:\n            high = middle -1\n        else:\n            return middle\n\n    return -1  # Not found\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-3\"></h2><ul>\n<li>In general, if the length of sequence is <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>\n<ul>\n<li>Linear search takes time proportional to <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span></li>\n<li>Binary search takes time proportional to <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">log(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span></li>\n</ul>\n</li>\n</ul></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"sorting-algorithms\">Sorting algorithms</h2><ul>\n<li>\n<p>Sorting algorithms sort a sequence into ascending or descending order.</p>\n<pre class=\"code\"><p>[1, 3, 2, 0] → [0, 1, 2, 3]\n[‘a’, ‘c’, ‘b’, ‘d’] →  [‘a’, ‘b’, ‘c’, ‘d’]</p></pre>\n</li>\n<li>\n<p>There are many sorting algorithms which have different speed and computer memory requirements.</p>\n</li>\n<li>\n<p>We will only cover two — Selection sort and Insertion sort</p>\n</li>\n</ul></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"selection-sort-algorithm-and-implementation\">Selection sort algorithm and implementation</h2><p>Visualize algorithm: <a href=\"https://visualgo.net/en/sorting\">https://visualgo.net/en/sorting</a></p></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-4\"></h2><python>def selection_sort(seq):\n    N = len(seq)\n    \n    for i in range(N):\n        # Assume that element at index i is minimum\n        min_index = i\n        \n        # Find minimum of unsorted elements on right of i\n        for k in range(i+1, N):\n            if seq[k] &#x3C;= seq[min_index]:\n                min_index = k\n\n        # Swap elements at i and min_index\n        temp = seq[i]\n        seq[i] = seq[min_index]\n        seq[min_index] = temp\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-5\"></h2><p>Run <inline-code>selectionsort.py</inline-code> to see the sequence after each iteration.</p></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"insertion-sort-algorithm-and-implementation\">Insertion sort algorithm and implementation</h2><p>Visualize algorithm: <a href=\"https://visualgo.net/en/sorting\">https://visualgo.net/en/sorting</a></p></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-6\"></h2><p>First let’s look at a single step when we have a partially sorted list of size <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span> and want to move an element to have a bigger partially sorted list of size <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>.</p></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-7\"></h2><python>sequence = [9, 22, 51, 63, 10, 79, 60, 75]  # partially sorted list\n\ni = 4\nkey = sequence[i]  # 10\n\n# Elements on the left of key are sorted.\n# We want to insert key on the left to keep the partial list sorted.\n# Shift elements one place to the right if they are greater than key. \nj = i - 1\nwhile(j >= 0 and sequence[j] > key):\n    sequence[j+1] = sequence[j]\n    j = j - 1\n\n# Moving key to index j+1\nsequence[j+1] = key\nprint(sequence)  # [9, 10, 22, 51, 63, 79, 60, 75]\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-8\"></h2><p>Now, we can look at the final insertion sort implementation:</p><python>def insertion_sort(seq):\n    N = len(seq)\n        \n    for i in range(1, N):\n        key = seq[i]\n        \n        # Elements on the left of key are already sorted.\n        # Shift them one place to the right if they are greater than key.\n        j = i - 1\n        while(j >= 0 and seq[j] > key):\n            seq[j+1] = seq[j]\n            j = j - 1\n        \n        # After shifting right, index j+1 is now available for key\n        seq[j+1] = key\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-9\"></h2><p>Run <inline-code>insertionsort.py</inline-code> to see the sequence after each iteration.</p><divider></divider></slide>","title":"13.1 — Binary Search, Sorting","date":"2023-03-23","published":true,"section":"Lecture-13.1"}},"__N_SSG":true}