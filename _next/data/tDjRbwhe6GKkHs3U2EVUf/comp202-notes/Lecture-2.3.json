{"pageProps":{"allSlugs":[["Lecture-1.1",[{"title":"1.1 — Programming Basics","slug":"Lecture-1.1"}]],["Lecture-1.2",[{"title":"1.2 — Variables, Arithmetic & String operations","slug":"Lecture-1.2"}]],["Lecture-2.1",[{"title":"2.1 — Function calls, Built-in functions, Expressions","slug":"Lecture-2.1"}]],["Lecture-2.2",[{"title":"2.2 —  Defining functions, Comparing Values, Control flow statements","slug":"Lecture-2.2"}]],["Lecture-2.3",[{"title":"2.3 — return vs. print, while statement","slug":"Lecture-2.3"}]],["Lecture-3.1",[{"title":"3.1 — Modules, String methods, break & continue statements","slug":"Lecture-3.1"}]],["Lecture-3.2",[{"title":"3.2 — Controlling print(), Nested Loops","slug":"Lecture-3.2"}]],["Lecture-3.3",[{"title":"3.3 — Scope of variables, Lists","slug":"Lecture-3.3"}]],["Lecture-4.1",[{"title":"4.1 — List methods, Tuples, Immutable objects","slug":"Lecture-4.1"}]],["Lecture-4.2",[{"title":"4.2 — Sets, Dictionaries","slug":"Lecture-4.2"}]],["Lecture-5.1",[{"title":"5.1 — Iterables, More dict & list operations, Nested lists","slug":"Lecture-5.1"}]],["Lecture-5.2",[{"title":"5.2 — Nested data structures, Comprehensions","slug":"Lecture-5.2"}]],["Lecture-5.3",[{"title":"5.3 — Sorting, Modules, Reading & Writing Files","slug":"Lecture-5.3"}]],["Lecture-6.1",[{"title":"6.1 — Files, Shallow vs. deep copy","slug":"Lecture-6.1"}]],["Lecture-6.2",[{"title":"6.2 — Handling exceptions, Object Oriented Programming (OOP)","slug":"Lecture-6.2"}]],["Lecture-7.1",[{"title":"7.1 — Object Oriented Programming (OOP)","slug":"Lecture-7.1"}]],["Lecture-7.2",[{"title":"7.2 — More OOP, Plotting using Matplotlib","slug":"Lecture-7.2"}]],["Lecture-7.3",[{"title":"7.3 — NumPy & Misc. topics","slug":"Lecture-7.3"}]]],"post":{"slug":"Lecture-2.3","content":"<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"traversing-a-string\">Traversing a string</h2><p>We can use <inline-code>for</inline-code> loop with <inline-code>range()</inline-code> function to go over a string letter-by-letter.</p><hgrid><python>message = \"Hello\"\n\nfor i in range(len(message)):\n    print(i, message[i])\n</python><output>0 H\n1 e\n2 l\n3 l\n4 o\n</output></hgrid></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"\"></h2><p>Another example:</p><python>letters = \"bcmrst\"\n\nfor i in range(len(letters)):\n    print(letters[i] + \"ake\")\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-1\"></h2><p>Try “Remove spaces from a string” problem on Ed Lessons.</p></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"equality-and-floating-point-numbers\">Equality and floating point numbers</h2><p>Consider following example:</p><python>>>> x = 1.1 + 2.2\n>>> x == 3.3  # why is this False?\nFalse\n</python><ul>\n<li>As we saw earlier, a floating-point number is stored with 64-bit <i>finite precision</i>.</li>\n<li>This means that a number may not be stored as precisely as we would like.</li>\n</ul></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"correct-way-to-check-if-two-float-values-are-equal\">Correct way to check if two <inline-code>float</inline-code> values are equal</h2><p>We should check if they are “close enough”.</p><python>>>> epsilon = 0.000001  # define how close two numbers need to be\n\n>>> x = 1.1 + 2.2\n>>> x\n3.3000000000000003\n\n# Check if x and 3.3 are within epsilon distance\n>>> abs(x - 3.3) &#x3C; epsilon\nTrue\n</python><p>The epsilon value depends on the application and how much error we are willing tolerate.</p></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-2\"></h2><div class=\"ppt-scale-1_25\"><p><b class=\"ppt-f80\">What does this mystery function do?</b></p><iframe width=\"800\" height=\"420\" scrolling=\"no\" style=\"overflow: hidden;\" frameborder=\"0\" src=\"https://pythontutor.com/iframe-embed.html#code=def%20mystery%28s%29%3A%20%20%20%20%20%0A%20%20%20%20result%20%3D%20%22%22%0A%20%20%20%20for%20i%20in%20range%28len%28s%29%29%3A%0A%20%20%20%20%20%20%20%20result%20%3D%20s%5Bi%5D%20%2B%20result%0A%0A%20%20%20%20return%20result%0A%0Anew_string%20%3D%20mystery%28%22hello%22%29%0Aprint%28new_string%29&#x26;codeDivHeight=400&#x26;codeDivWidth=350&#x26;cumulative=false&#x26;curInstr=0&#x26;heapPrimitives=true&#x26;origin=opt-frontend.js&#x26;py=3&#x26;rawInputLstJSON=%5B%5D&#x26;textReferences=false\"> </iframe></div></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"functions-and-return-value-none\">Functions and return value <inline-code>None</inline-code></h2><p>Functions that do not have an explicit <inline-code>return</inline-code> statement, return a special value <inline-code>None</inline-code>.</p></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-3\"></h2><p>The following 3 functions are equivalent because</p><ul>\n<li>Python implicitly returns <inline-code>None</inline-code> for a function that does not  use a return statement</li>\n<li>if the <inline-code>return</inline-code> statement is used without a value, <inline-code>None</inline-code> is returned.</li>\n</ul><python>def greeting():\n    print(\"Welcome!\")\n</python><hgrid><python>def greeting():\n    print(\"Welcome!\")\n    return\n</python><python>def greeting():\n    print(\"Welcome!\")\n    return None\n</python></hgrid></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-4\"></h2><hgrid><div><p><b>Function that prints</b></p><python>def f(x):\n    result = x * x - x - 1\n    print(result)\n\nf(5)  # No print here\n\ny = f(10) + 10  # TypeError\n</python><p>Less flexible to use; cannot be used with other expressions</p></div><div><p><b>Function that returns a value</b></p><python>def f(x):  \n    result = x * x - x - 1\n    return result\n\nprint(f(5))  # print here\n\ny = f(10) + 10  # works\n</python><p>More flexible to use; can be used with other expressions</p></div></hgrid></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-5\"></h2><p>Try the problem “Max of three numbers” on Ed Lessons.</p></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"short-circuit-evaluation\">Short Circuit Evaluation</h2><p>The evaluation of a boolean expression with <inline-code>and</inline-code> and <inline-code>or</inline-code> stops as soon as the end result can be inferred.</p><p>For example, in the expression below evaluates to <inline-code>False</inline-code> no matter what <inline-code>not (x >= 1 or y == 3)</inline-code> evaluates to.</p><python lineno=\"false\">>>> 2 &#x3C; 1 and not (x >= 1 or y == 3)\nFalse\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-6\"></h2><p>In general, for any expression with <inline-code>and</inline-code> operator:</p><python lineno=\"false\">left_operand and right_operand\n</python><p>if <inline-code>left_operand</inline-code> is <inline-code>False</inline-code>, Python does not evaluate <inline-code>right_operand</inline-code>.</p></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-7\"></h2><p>Similarly, for any expression with <inline-code>or</inline-code> operator:</p><python lineno=\"false\">left_operand or right_operand\n</python><p>if <inline-code>left_operand</inline-code> is <inline-code>True</inline-code>, Python does not evaluate <inline-code>right_operand</inline-code>.</p><p>For example,</p><python lineno=\"false\"># Evaluates to True no matter what (x &#x3C; 5) evaluates to\n>>> 1 == 1 or (x &#x3C; 5)\nTrue\n</python></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"why-is-short-circuit-evaluation-useful\">Why is Short Circuit Evaluation useful?</h2><ul>\n<li>It can save time, e.g. when <inline-code>right_operand</inline-code> has a computationally expensive function call.</li>\n<li>It can avoid unnecessary errors as show below.</li>\n</ul><python>>>> x = 0\n>>> 1 / x &#x3C; 0.5  # cannot divide a number by zero\nZeroDivisionError: division by zero\n\n>>> x != 0 and 1 / x &#x3C; 0.5\nFalse\n>>> x = 3\n>>> x != 0 and 1 / x &#x3C; 0.5\nTrue\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-8\"></h2><p><b>Common mistake when using logical operators</b></p><hgrid><python lineno=\"false\">x == \"a\" or \"b\"  # Incorrect\n\nx == \"a\" or x == \"b\"  # Correct\n</python><python lineno=\"false\">x == \"a\" and \"b\"  # Incorrect\n\nx == \"a\" and x == \"b\"  # Correct\n</python></hgrid></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"while-statement\"><inline-code>while</inline-code> statement</h2><p><inline-code>while</inline-code> statement is another way to repeatedly execute a block of code.</p><p>General format of a while loop:</p><div class=\"px1 py025 br5\" style=\"background-color: white; width: 90%; white-space: pre;\"><p><code>Initialize variables so that</code> <code class=\"bggreen ibox\">condition</code> <code>is True</code>\n<code class=\"b\">while</code> <code class=\"bggreen ibox\">condition</code> <code class=\"b\">:</code>\n<code>    </code><code class=\"bgblue ibox\">code block</code>\n<code>    </code><code>update variables that affect</code> <code class=\"bggreen ibox\">condition</code></p></div></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-9\"></h2><p>What <inline-code>while</inline-code> loop does:</p><ol>\n<li>Evaluate the <code class=\"bggreen ibox\">condition</code></li>\n<li>If <code class=\"bggreen ibox\">condition</code> evaluates to <inline-code>False</inline-code>, loop body is not executed.</li>\n<li>If <code class=\"bggreen ibox\">condition</code> evaluates to <inline-code>True</inline-code>, run the loop body (all indented lines of code)<br>\na) In loop body we perform some task, <code class=\"bgblue ibox\">code block</code>, and update variables that may change the <code class=\"bggreen ibox\">condition</code> value<br>\nb) Go back to step 1</li>\n</ol></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-10\"></h2><python># a program to compute sum of first N numbers\nN = 10\n\ntotal = 0\n\ni = 1  # Set value so that condition below is True \nwhile i &#x3C;= N:  # Check if condition is True\n    # main task of summing numbers:\n    total = total + i  \n    \n    # update i, affects value of condition i &#x3C;= N \n    i = i + 1\n\n# print result outside the loop   \nprint(total)\n</python></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-11\"></h2><p>It is a common mistake to forget updating the condition inside loop body.</p><p>See what happens when you remove/comment out the line <inline-code>i = i + 1</inline-code> in the previous example.</p><p>The loop will never end — an infinite loop!</p></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"augmented-assignment-statements\">Augmented assignment statements</h2><p>Augmented assignment is the combination, in a single statement, of a arithmetic operation and an assignment statement:</p><hgrid><python>x = 3\ny = 5\n\nx += 1  # same as: x = x + 1\nx += y  # x = x + y\nx += x * y  # x = x + x * y\n\nx -= 5  # x = x - 5\n\nx *= 2  # x = x * 2\n</python><div><ul>\n<li>Similarly, other operators exist: <inline-code>/=</inline-code>, <inline-code>//=</inline-code>, <inline-code>%=</inline-code>, <inline-code>**=</inline-code>.</li>\n<li>These are very useful, especially when updating the condition in while loop.</li>\n</ul></div></hgrid></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"loops-with-indefinite-number-of-steps\">Loops with indefinite number of steps</h2><p>So far we have seen loops that work with fixed number of steps.</p><p>But while loop can be used for repeating code for unknown number of steps.</p><greenbox><p>Write a program to keep asking for password until correct password is entered.</p><p>Assume that correct (secret) password is <inline-code>abcd1234</inline-code>.</p></greenbox></slide>\n<slide class=\"slide-notitle\"><h2 class=\"slide-title\" style=\"\" id=\"-12\"></h2><python>password = input(\"Enter password: \")\n\nwhile password != \"abcd1234\":\n    print(\"Incorrect password, try again!\")\n    \n    password = input(\"Enter password: \")\n    \n# Below line executes only after the above loop ends,\n# i.e. when the correct password was entered.\nprint(\"Login successful!\")\n</python></slide>\n<slide class=\"slide-normal\"><h2 class=\"slide-title\" style=\"\" id=\"for-vs-while-loops\"><inline-code>for</inline-code> vs <inline-code>while</inline-code> loops</h2><ul>\n<li><inline-code>for</inline-code> loops are better when we want to go over a fixed sequence such as a string or a sequence of numbers</li>\n<li><inline-code>while</inline-code> loop is more flexible as it allows arbitrary conditions and number of steps. e.g. do something until user enters correct data</li>\n</ul><divider></divider></slide>","title":"2.3 — return vs. print, while statement","date":"2024-05-09","published":true,"section":"Lecture-2.3"}},"__N_SSG":true}