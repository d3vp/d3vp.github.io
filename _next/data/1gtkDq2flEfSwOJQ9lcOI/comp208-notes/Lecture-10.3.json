{"pageProps":{"titles":["2.1 — Programming Basics","2.2 — Variables, Arithmetic & String operations","2.3 — Function Calls, Expressions","3.1 — Defining functions, Errors & Debugging","3.2 — Boolean Expressions, Comparison & Logical Operators","3.3 — Conditional execution using if statement","3.4 — for loop & String indexing, slicing","Python Style Guide","4.1 — Escape Characters & Controlling print()","4.2 — String methods & in operator","4.3 — while statement & Nested loops","4.4 — return statement & Importing modules","5.1 — Scope of Variables","5.2 — Lists & List Operations","5.3 — List Functions & Methods","5.4 — Tuples","6.1 — Object Identity, Immutability, Unpacking","6.2 — Sets","6.3 — Dictionaries","7.1 — Nested data structures & comparisons","7.2 — Iterables & comprehensions","7.3 — Reading and writing files","8.1 — Default arguments & Modules","8.2 — Handling Exceptions","9.1 — Object Oriented Programming (OOP)","9.2 — More on methods & __str__","10.1 — NumPy","10.2 — Plotting using Matplotlib","Week 10 — More on NumPy","11.1 — Root finding","11.2 — Interpolation & Curve fitting"],"slugs":["Lecture-2.1","Lecture-2.2","Lecture-2.3.1","Lecture-3.1","Lecture-3.2","Lecture-3.3","Lecture-3.4","style-guide","Lecture-4.1","Lecture-4.2","Lecture-4.3","Lecture-4.4","Lecture-5.1","Lecture-5.2","Lecture-5.3","Lecture-5.4","Lecture-6.1","Lecture-6.2","Lecture-6.3","Lecture-7.1","Lecture-7.2","Lecture-7.3","Lecture-8.1","Lecture-8.2","Lecture-9.1","Lecture-9.2","Lecture-10.1","Lecture-10.2","Lecture-10.3","Lecture-11.1","Lecture-11.2"],"post":{"title":"Week 10 — More on NumPy","slug":"Lecture-10.3","content":"<h2>Creating NumPy arrays</h2>\n<p><inline-code>np.array</inline-code> infers <inline-code>dtype</inline-code> based on types of numbers in the argument.</p>\n<python>x = np.array([10, 20, 30])\nprint(x) #[10 20 30]\nprint(x.dtype) # int64\n\nx = np.array([1.2, 3.14, 10.15])\nprint(x) #[ 1.2   3.14 10.15]\nprint(x.dtype) # float64\n\nx = np.array([10.0, 20, 30])\nprint(x) #[10. 20. 30.]\nprint(x.dtype) # float64\n\n\n# we can explicity specify what dtype we want:\nx = np.array([10, 20, 30], dtype=float)\nprint(x) #[10. 20. 30.]\nprint(x.dtype) # float64\n\n# float is truncated to int (not rounded)\nx = np.array([1.2, 3.14, 10.65], dtype=int)\nprint(x) #[ 1  3 10]\nprint(x.dtype) # int64\n</python>\n<h2>Different shapes for different purposes</h2>\n<div class=\"flex\" style=\"align-items: center;\"><pre><code>[1.0 5.0 3.5 4.0 5.0 1.2]\n</code></pre><div><p>One point in 6D euclidean space</p></div></div>\n<div class=\"flex\" style=\"align-items: center;\"><pre><code>[[1.0 5.0 3.5]\n [4.0 5.0 1.2]]\n</code></pre><div><p>Two points in 3D euclidean space</p></div></div>\n<div class=\"flex\" style=\"align-items: center;\"><pre><code>[[1.0 5.0]\n [3.5 4.0]\n [5.0 1.2]]\n</code></pre><div><p>Three points in 2D euclidean space</p></div></div>\n<python>import numpy as np\n\n\nx = np.arange(1, 13) # 1D array\nprint(x)\n# [ 1  2  3  4  5  6  7  8  9 10 11 12]\n\n\n# 2D array, a 3x4 matrix\nmatrix1 = x.reshape((3, 4))\nprint(matrix1)\n# [[ 1  2  3  4]\n#  [ 5  6  7  8]\n#  [ 9 10 11 12]]\n\n\n# 2D array, a 2x6 matrix\nmatrix2 = matrix1.reshape((2, 6))\nprint(matrix2)\n# [[ 1  2  3  4  5  6]\n#  [ 7  8  9 10 11 12]]\n\n\ny = matrix2.reshape((12,)) # 1D array\nprint(y)\n# [ 1  2  3  4  5  6  7  8  9 10 11 12]\n</python>\n<h2>Special values — <inline-code>numpy.nan</inline-code>, <inline-code>numpy.inf</inline-code></h2>\n<p>Numpy has special values to represent invalid or extreme values that result from numerical computation</p>\n<ul>\n<li><inline-code>numpy.nan</inline-code> (not a number)</li>\n<li><inline-code>numpy.inf</inline-code>  (infinity)</li>\n</ul>\n<python>import numpy as np\n\narr = np.array([-1, 0, 1, 2, 3, 4])\n\nprint(np.log(arr))\n#[       nan       -inf 0.         0.69314718 1.09861229 1.38629436]\n\n# Any operation on np.nan results in np.nan\nprint(np.nan * 10, 0 / np.nan)\n# nan nan\n\n# Some operations are allowed on np.inf\n\nprint(np.inf, -np.inf)\n# inf -inf\n\nprint(0 / np.inf, 1 / np.inf)\n# 0.0 0.0\n\nprint(np.inf * np.inf, 100 + np.inf)\n# inf inf\n</python>\n<h1>Slicing 2D array</h1>\n<img src=\"week10/course_array.png\" style=\"width: 80%; margin: 0 0 0 2em;\">\n<python>import numpy as np\n\ngrades = np.array([[94, 84, 97, 79],\n                   [81, 88, 93, 85],\n                   [87, 95, 86, 77]])\n\nprint('Grades for student 1, course 2:')\nprint(grades[1, 2])  # 93\n\n\nprint('All grades for student 2:')\nprint(grades[2, :])  # [87 95 86 77]\n\nprint('All grades for course 0:')\nprint(grades[:, 0])  # [94 81 87]\n</python>\n<h2>Assigning values using indices and slices</h2>\n<python>import numpy as np\n\ngrades = np.array([[94, 84, 97, 79],\n                   [81, 88, 93, 85],\n                   [87, 95, 86, 77]])\n\n# Setting same value to all indices in the slice\ngrades[0:2, 1:3] = 100\nprint(grades)\n# [[ 94 100 100  79]\n#  [ 81 100 100  85]\n#  [ 87  95  86  77]]\n\n# Setting values from array of same shape\ngrades[0:2, 1:3] = np.array([[10, 20], [30, 40]])\nprint(grades)\n# [[94 10 20 79]\n#  [81 30 40 85]\n#  [87 95 86 77]]\n</python>\n<h2>Using list/array of booleans as index</h2>\n<p>When comparison operators are used with NumPy arrays, result is an array of boolean values.</p>\n<python>import numpy as np\n\narr = np.array([10, 11, 12, 13, 14, 15, 16, 17])\nprint(arr % 2 == 0) # produces numpy array of booleans\n# [ True False  True False  True False  True False]\n</python>\n<p>We can use a list/array of booleans as index to select elements of NumPy array</p>\n<python>import numpy as np\n\narr = np.array([10, 11, 12, 13])\nindices = [True, False, False, True]\nprint(arr[indices])\n# [10 13]\n\narr = np.array([10, 11, 12, 13, 14, 15, 16, 17])\nprint(arr[arr % 2 == 0])\n# [10 12 14 16]\n\n\narr = np.array([-10, -20, 0, 24, -50, 33, 10])\nprint(arr[arr > 0])\n# [24 33 10]\n</python>\n<h2>Using a list/array of integers as index</h2>\n<p>Multiple elements of a numpy array can be selected using a list or an array of indices</p>\n<python>nums = np.arange(10, 100, 10)\n# [10 20 30 40 50 60 70 80 90]\n\nindices = [0, 1, 5]\nprint(nums[indices]) # [10 20 60]\n\n# Output will be in same order as indices\nindices = np.array([2, 8, 5, 1])\nprint(nums[indices]) # [30 90 60 20]\n</python>\n<p>For 2D arrays,</p>\n<python>import numpy as np\n\nmatrix = np.arange(1, 13).reshape((3,4))\nprint(matrix)\n# [[ 1  2  3  4]\n#  [ 5  6  7  8]\n#  [ 9 10 11 12]]\n\nrow_indices = [0, 2]  \nprint(matrix[row_indices, :]) # Select rows 0 &#x26; 2\n# [[ 1  2  3  4]\n#  [ 9 10 11 12]]\n\ncol_indices = [1, 2]\nprint(matrix[:, col_indices]) # Select columns 1 &#x26; 2\n# [[ 2  3]\n#  [ 6  7]\n#  [10 11]]\n\n# Select numbers at (0, 1) and  (2, 2)\nprint(matrix[row_indices, col_indices])\n# [ 2 11]\n</python>\n<p><img style=\"display: block; margin: 3em auto; width: 15%;\" src=\"../assets/divider.svg\"></p>"}},"__N_SSG":true}